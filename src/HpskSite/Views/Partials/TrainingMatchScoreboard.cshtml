@*
    Training Match Scoreboard Partial
    Displays the paper-like scoreboard with participant columns
*@

<!-- Spectator Banner - Note: avoid d-flex class as it has !important that overrides JS -->
<div class="alert alert-info align-items-center mb-3" id="spectatorBanner" style="display: none;">
    <i class="bi bi-eye-fill me-2 fs-5"></i>
    <div>
        <strong>Du tittar som 친sk친dare</strong>
        <span class="ms-2 d-none d-sm-inline">- Du kan se resultaten i realtid men inte delta</span>
    </div>
    <button type="button" class="btn btn-sm btn-outline-primary ms-auto" onclick="requestJoinCurrentMatch()">
        <i class="bi bi-person-plus me-1"></i>G친 med
    </button>
</div>

<!-- Scheduled Match Banner (for creator) -->
<div class="alert alert-warning align-items-center mb-3" id="scheduledMatchBannerCreator" style="display: none;">
    <i class="bi bi-clock-fill me-2 fs-5"></i>
    <div>
        <strong>Schemalagd match</strong>
        <span class="ms-2">Startar: <span id="scheduledStartTimeCreator">-</span></span>
        <small class="d-block text-muted mt-1">Du kan l칛gga till resultat efter starttiden.</small>
    </div>
</div>

<!-- Scheduled Match Banner (for participants - cannot add scores yet) -->
<div class="alert alert-info align-items-center mb-3" id="scheduledMatchBannerParticipant" style="display: none;">
    <i class="bi bi-hourglass-split me-2 fs-5"></i>
    <div>
        <strong>Matchen har inte startat</strong>
        <span class="ms-2">Startar: <span id="scheduledStartTimeParticipant">-</span></span>
        <small class="d-block mt-1">Du kan registrera resultat n칛r matchen startar.</small>
    </div>
</div>

<!-- Match Header -->
<div class="card mb-3">
    <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center flex-wrap gap-2">
        <div>
            <h5 class="mb-0" id="matchTitle">
                <i class="bi bi-people-fill me-2"></i><span id="matchNameDisplay">Match</span>
            </h5>
            <small>
                <span id="matchWeaponClass">Klass C</span> |
                Kod: <strong id="matchCodeDisplay">------</strong>
                <span id="handicapBadge" class="badge bg-warning text-dark ms-2" style="display: none;" title="Handicapsystem aktiverat">
                    <i class="bi bi-balance-scale me-1"></i>HCP
                </span>
            </small>
        </div>
        <div class="d-flex align-items-center gap-2">
            <!-- Spectators Display -->
            <div id="spectatorsDisplay" class="d-flex align-items-center" style="display: none !important;" onclick="showSpectatorsModal()" role="button" title="Visa 친sk친dare">
                <i class="bi bi-eye text-light me-1"></i>
                <div id="spectatorAvatars" class="d-flex" style="margin-right: 4px;">
                    <!-- Spectator avatars will be added dynamically -->
                </div>
                <span id="spectatorCount" class="badge bg-light text-primary">0</span>
            </div>
            <div class="btn-group" id="matchActionButtons">
                <!-- Settings button (creator only) -->
                <button type="button" class="btn btn-light" id="matchSettingsBtn" onclick="showMatchSettingsModal()" title="Inst칛llningar" style="display:none; font-size: 1.25rem; padding: 0.25rem 0.5rem;">
                    <i class="bi bi-gear-fill"></i>
                </button>
                <!-- Share and Leave buttons (non-creator participants) -->
                <button type="button" class="btn btn-light btn-sm" onclick="showShareModal()" title="Dela" id="shareMatchBtn">
                    <i class="bi bi-share"></i> <span class="d-none d-sm-inline">Dela</span>
                </button>
                <button type="button" class="btn btn-warning btn-sm" id="leaveMatchBtn" onclick="leaveMatch()" title="L칛mna">
                    <i class="bi bi-box-arrow-left"></i>
                </button>
                <!-- Spectator exit button -->
                <button type="button" class="btn btn-secondary btn-sm" id="exitSpectatorBtn" onclick="exitSpectatorMode()" title="St칛ng" style="display:none;">
                    <i class="bi bi-x-lg"></i>
                </button>
                <!-- End match button (hidden, only shown in settings modal for creator) -->
                <button type="button" class="btn btn-danger btn-sm" id="endMatchBtn" onclick="completeMatch()" title="Avsluta" style="display:none;">
                    <i class="bi bi-stop-circle"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Spectators Modal -->
<div class="modal fade" id="spectatorsModal" tabindex="-1" aria-labelledby="spectatorsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="spectatorsModalLabel">
                    <i class="bi bi-eye me-2"></i>칀sk친dare
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="St칛ng"></button>
            </div>
            <div class="modal-body">
                <div id="spectatorsList" class="list-group">
                    <!-- Spectators will be listed here -->
                </div>
                <div id="noSpectatorsMessage" class="text-center text-muted py-3" style="display: none;">
                    <i class="bi bi-eye-slash fs-3 d-block mb-2"></i>
                    Inga 친sk친dare just nu
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Match Settings Modal (Creator only) -->
<div class="modal fade" id="matchSettingsModal" tabindex="-1" aria-labelledby="matchSettingsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="matchSettingsModalLabel">
                    <i class="bi bi-gear me-2"></i>Matchinst칛llningar
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="St칛ng"></button>
            </div>
            <div class="modal-body">
                <!-- Max Series Count Setting -->
                <div class="mb-4">
                    <label for="maxSeriesCountInput" class="form-label fw-bold">
                        <i class="bi bi-list-ol me-1"></i>Max antal serier
                    </label>
                    <div class="input-group">
                        <input type="number" class="form-control" id="maxSeriesCountInput"
                               min="1" max="20" placeholder="L칛mna tomt f칬r automatiskt">
                        <button type="button" class="btn btn-primary" onclick="saveMatchSettings()">
                            <i class="bi bi-check-lg me-1"></i>Spara
                        </button>
                    </div>
                    <div class="form-text">
                        Begr칛nsa totalsumman till detta antal serier. L칛mna tomt f칬r att anv칛nda minsta antal skjutna serier.
                    </div>
                </div>

                <!-- Share Section -->
                <div class="mb-4">
                    <label class="form-label fw-bold">
                        <i class="bi bi-share me-1"></i>Bjud in deltagare
                    </label>
                    <p class="text-muted small mb-2">Registrerade anv칛ndare kan ange matchkoden i appen f칬r att g친 med.</p>

                    <!-- Match Code (inline) -->
                    <div class="d-flex align-items-center justify-content-center gap-2 mb-3">
                        <span class="text-muted">Matchkod:</span>
                        <span class="fs-4 fw-bold font-monospace" id="settingsMatchCode"></span>
                    </div>

                    <!-- Share Link with Copy and QR buttons -->
                    <div class="input-group input-group-sm">
                        <input type="text" class="form-control" id="settingsMatchLink" readonly>
                        <button class="btn btn-outline-primary" type="button" onclick="copyMatchLinkFromSettings()">
                            <i class="bi bi-clipboard"></i> Kopiera
                        </button>
                        <button class="btn btn-outline-secondary" type="button" onclick="toggleSettingsQrCode()">
                            <i class="bi bi-qr-code"></i> QR
                        </button>
                    </div>

                    <!-- QR Code (collapsible) -->
                    <div id="settingsQrCodeContainer" class="text-center mt-3" style="display: none;">
                        <img id="settingsQrCode" src="" alt="QR-kod" class="img-fluid" style="max-width: 180px; border-radius: 8px;">
                    </div>
                </div>

                <!-- Guest Management Section (if allowed) -->
                <div class="mb-4" id="guestManagementSection" style="display: none;">
                    <label class="form-label fw-bold">
                        <i class="bi bi-person-plus me-1"></i>G칛sthantering
                    </label>
                    <p class="text-muted small mb-2">L칛gg till g칛ster som inte har konto f칬r att delta i matchen.</p>
                    <button type="button" class="btn w-100" style="background-color: #0891b2; border-color: #0891b2; color: white;" onclick="showAddGuestModal()">
                        <i class="bi bi-person-plus me-2"></i>L칛gg till g칛st
                    </button>
                </div>

                <!-- Member Claim Section (for members who forgot password) -->
                <div class="mb-4" id="memberClaimSection" style="display: none;">
                    <label class="form-label fw-bold">
                        <i class="bi bi-person-badge me-1"></i>Medlem utan inloggning
                    </label>
                    <p class="text-muted small mb-2">L칛gg till en registrerad medlem som gl칬mt sitt l칬senord.</p>
                    <button type="button" class="btn btn-primary w-100" onclick="showAddMemberModal()">
                        <i class="bi bi-qr-code me-2"></i>L칛gg till medlem utan inloggning
                    </button>
                </div>

                <!-- End Match Button -->
                <div class="border-top pt-3">
                    <button type="button" class="btn btn-danger w-100" onclick="confirmEndMatch()">
                        <i class="bi bi-stop-circle me-2"></i>Avsluta match
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Scoreboard Container -->
<div class="scoreboard-container">
    <div class="scoreboard-scroll">
        <table class="scoreboard-table" id="scoreboardTable">
            <thead>
                <tr id="participantHeaderRow">
                    <!-- Participant columns will be added dynamically -->
                </tr>
            </thead>
            <tbody id="scoreboardBody">
                <!-- Score rows will be added dynamically -->
            </tbody>
        </table>
    </div>
</div>

<!-- Emoji Reaction Picker -->
<div id="emojiPicker" class="emoji-picker" style="display: none;">
    <div class="emoji-picker-content">
        <button type="button" class="emoji-btn" data-emoji="仇벒잺" title="Hj칛rta">仇벒잺</button>
        <button type="button" class="emoji-btn" data-emoji="游녨" title="Tumme upp">游녨</button>
        <button type="button" class="emoji-btn" data-emoji="游댠" title="Eld">游댠</button>
        <button type="button" class="emoji-btn" data-emoji="游땩" title="Ledsen">游땩</button>
        <button type="button" class="emoji-btn" data-emoji="游꿢" title="Prickskytt">游꿢</button>
    </div>
</div>

<!-- Target Photo Viewer Modal -->
<div class="modal fade" id="targetPhotoModal" tabindex="-1" aria-labelledby="targetPhotoModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="targetPhotoModalLabel">
                    <i class="bi bi-camera me-2"></i>M친lfoto - Serie <span id="photoSeriesNumber">1</span>
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="St칛ng"></button>
            </div>
            <div class="modal-body text-center p-3">
                <div id="photoLoadingSpinner" class="py-5">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Laddar...</span>
                    </div>
                </div>
                <img id="targetPhotoImage" src="" alt="M친lfoto" class="img-fluid rounded" style="max-height: 70vh; display: none;">
                <div id="noPhotoMessage" class="py-5 text-muted" style="display: none;">
                    <i class="bi bi-camera-video-off fs-1 d-block mb-3"></i>
                    <p>Inget m친lfoto f칬r denna serie</p>
                </div>
                <!-- Score info -->
                <div id="photoScoreInfo" class="mt-3 p-3 bg-light rounded">
                    <div class="d-flex justify-content-center align-items-center gap-4">
                        <div>
                            <span class="fs-3 fw-bold" id="photoScoreTotal">48</span>
                            <small class="text-muted d-block">Po칛ng</small>
                        </div>
                        <div id="photoXCountContainer">
                            <span class="fs-4 text-warning fw-bold" id="photoXCount">2x</span>
                            <small class="text-muted d-block">X-tr칛ffar</small>
                        </div>
                        <div id="photoShooterContainer">
                            <span class="fs-5" id="photoShooterName">Stefan</span>
                            <small class="text-muted d-block">Skytt</small>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer justify-content-between">
                <div class="emoji-reaction-row">
                    <span class="me-2 text-muted small">Reagera:</span>
                    <button type="button" class="btn btn-outline-secondary btn-sm emoji-modal-btn" data-emoji="仇벒잺">仇벒잺</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm emoji-modal-btn" data-emoji="游녨">游녨</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm emoji-modal-btn" data-emoji="游댠">游댠</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm emoji-modal-btn" data-emoji="游땩">游땩</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm emoji-modal-btn" data-emoji="游꿢">游꿢</button>
                </div>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">St칛ng</button>
            </div>
        </div>
    </div>
</div>

<!-- Reactors Popup Modal -->
<div class="modal fade" id="reactorsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-sm">
        <div class="modal-content">
            <div class="modal-header py-2">
                <h6 class="modal-title"><i class="bi bi-emoji-smile me-2"></i>Reaktioner</h6>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body py-2">
                <div id="reactorsList"></div>
            </div>
        </div>
    </div>
</div>

<!-- Add Score Button (floating) -->
<div class="fixed-bottom pb-4 pe-4 text-end" style="pointer-events: none;">
    <button type="button" class="btn btn-success btn-lg shadow" id="addScoreBtn"
            onclick="handleAddScoreClick()" style="pointer-events: auto;">
        <i class="bi bi-plus-circle me-1"></i> L칛gg till serie
    </button>
</div>

<script>
// IMPORTANT: These calculation functions must match HpskSite.Shared.Services.ResultCalculator
// to ensure mobile app and web site produce identical results.
// JavaScript Math.round() uses standard rounding (away from zero), which matches
// the C# ResultCalculator.StandardRounding (MidpointRounding.AwayFromZero).

// Helper functions for quarter-point handicap display
function roundToQuarter(value) {
    return Math.round(value * 4) / 4;
}

// Calculate adjusted total with per-series handicap clamping
// Each series is adjusted and clamped between 0-50 individually, then summed
function calculateAdjustedTotalWithCap(scores, handicapPerSeries) {
    // Short-circuit for zero handicap
    if (handicapPerSeries === 0) {
        const rawTotal = scores.reduce((sum, s) => sum + Math.min(s.total, 50), 0);
        return { total: rawTotal, effectiveHandicap: 0 };
    }

    let total = 0;
    let effectiveHandicap = 0;
    for (const s of scores) {
        const rawCapped = Math.min(s.total, 50);
        const adjusted = rawCapped + handicapPerSeries;
        const rounded = Math.round(adjusted);
        // Clamp between 0 and 50 (handles both positive and negative handicaps)
        const clamped = Math.max(0, Math.min(rounded, 50));
        total += clamped;
        effectiveHandicap += (clamped - rawCapped);
    }
    return { total, effectiveHandicap };
}

// Build inline reaction HTML with responsive display
function buildInlineReactionHtml(reactions) {
    if (!reactions || reactions.length === 0) {
        return '';
    }

    // Group reactions by emoji
    const grouped = {};
    reactions.forEach(r => {
        if (!grouped[r.emoji]) {
            grouped[r.emoji] = { emoji: r.emoji, count: 0, names: [] };
        }
        grouped[r.emoji].count++;
        grouped[r.emoji].names.push(r.firstName || 'Ok칛nd');
    });

    const groups = Object.values(grouped).sort((a, b) => b.count - a.count);
    const totalCount = reactions.length;
    const tooltip = reactions.map(r => `${r.firstName || 'Ok칛nd'}: ${r.emoji}`).join(', ');

    // Escape data for HTML attributes
    const groupsJson = JSON.stringify(groups).replace(/'/g, '&#39;').replace(/"/g, '&quot;');
    const reactionsJson = JSON.stringify(reactions).replace(/'/g, '&#39;').replace(/"/g, '&quot;');

    return ` <span class="reaction-display"
                   data-reactions="${groupsJson}"
                   data-total="${totalCount}"
                   title="${tooltip}"
                   onclick="event.stopPropagation(); openReactorsPopup(this)">
             </span>`;
}

// Update all reaction displays based on available cell width
function updateReactionDisplays() {
    document.querySelectorAll('.reaction-display').forEach(container => {
        try {
            const groupsData = container.dataset.reactions;
            if (!groupsData) return;

            const groups = JSON.parse(groupsData.replace(/&quot;/g, '"').replace(/&#39;/g, "'"));
            const total = parseInt(container.dataset.total) || 0;
            const cell = container.closest('.score-cell');
            const cellWidth = cell ? cell.offsetWidth : 80;

            let html = '';

            if (cellWidth >= 120) {
                // Wide: All unique emojis in a row
                html = groups.map(g => `<span class="reaction-emoji">${g.emoji}</span>`).join('');
            } else if (cellWidth >= 90) {
                // Medium: Grouped with counts (top 2)
                html = groups.slice(0, 2).map(g =>
                    `<span class="reaction-grouped">${g.emoji}${g.count > 1 ? g.count : ''}</span>`
                ).join('');
            } else {
                // Narrow: First emoji + count badge
                const first = groups[0];
                html = `<span class="reaction-compact">${first.emoji}${total > 1 ? '+' + (total - 1) : ''}</span>`;
            }

            container.innerHTML = html;
        } catch (e) {
            console.error('Error updating reaction display:', e);
        }
    });
}

// Debounce helper for resize events
function debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// Update reaction displays on window resize
window.addEventListener('resize', debounce(updateReactionDisplays, 150));

// Open reactors popup showing who reacted with what
function openReactorsPopup(triggerElement) {
    const list = document.getElementById('reactorsList');
    if (!list) return;

    try {
        const groupsData = triggerElement.dataset.reactions;
        if (!groupsData) return;

        const groups = JSON.parse(groupsData.replace(/&quot;/g, '"').replace(/&#39;/g, "'"));

        list.innerHTML = groups.map(g => `
            <div class="d-flex align-items-center gap-2 py-1">
                <span class="fs-4">${g.emoji}</span>
                <span class="text-muted small flex-grow-1">${g.names.join(', ')}</span>
                <span class="badge bg-secondary">${g.count}</span>
            </div>
        `).join('');

        new bootstrap.Modal(document.getElementById('reactorsModal')).show();
    } catch (e) {
        console.error('Error opening reactors popup:', e);
    }
}

function formatHandicap(value) {
    const rounded = roundToQuarter(value);
    const sign = rounded >= 0 ? '+' : '';
    // Show decimals only if not a whole number
    const formatted = Number.isInteger(rounded) ? rounded.toString() : rounded.toFixed(2);
    return sign + formatted;
}

// Calculate rankings for participants based on adjusted total scores
function calculateParticipantRankings(match) {
    const rankings = {};

    // Calculate adjusted total for each participant
    const participantsWithScores = match.participants.filter(p => p.scores && p.scores.length > 0);
    const minSeriesCount = participantsWithScores.length > 0
        ? Math.min(...participantsWithScores.map(p => p.scores.length))
        : 0;

    const participantScores = match.participants.map(p => {
        const allScores = p.scores || [];
        const actualSeriesCount = allScores.length;

        // Determine effective limit (same logic as total row)
        let effectiveLimit;
        if (match.maxSeriesCount) {
            effectiveLimit = Math.min(match.maxSeriesCount, actualSeriesCount);
        } else {
            effectiveLimit = Math.min(minSeriesCount, actualSeriesCount);
        }

        const effectiveScores = allScores
            .sort((a, b) => a.seriesNumber - b.seriesNumber)
            .slice(0, effectiveLimit);

        // Calculate raw total (capped at 50 per series)
        const rawTotal = effectiveScores.reduce((sum, s) => sum + Math.min(s.total, 50), 0);
        const effectiveSeriesCount = effectiveScores.length;

        // Calculate adjusted total with handicap (per-series capping)
        let adjustedTotal = rawTotal;
        if (match.hasHandicap && p.handicapPerSeries !== null && p.handicapPerSeries !== undefined) {
            const hcpPerSeries = roundToQuarter(p.handicapPerSeries);
            const result = calculateAdjustedTotalWithCap(effectiveScores, hcpPerSeries);
            adjustedTotal = result.total;
        }

        return {
            memberId: p.memberId,
            guestParticipantId: p.guestParticipantId,
            adjustedTotal: adjustedTotal
        };
    });

    // Sort by adjusted total descending
    participantScores.sort((a, b) => b.adjustedTotal - a.adjustedTotal);

    // Assign rankings
    participantScores.forEach((p, index) => {
        const key = p.memberId || `guest_${p.guestParticipantId}`;
        rankings[key] = index + 1;
    });

    return rankings;
}

// Get ranking color (gold/silver/bronze for top 3, gray for others)
function getRankingColor(ranking) {
    switch (ranking) {
        case 1: return '#FFD700'; // Gold
        case 2: return '#C0C0C0'; // Silver
        case 3: return '#CD7F32'; // Bronze
        default: return ranking > 0 ? '#9CA3AF' : null; // Gray for non-podium
    }
}

// Get ranking text for all participants
function getRankingText(ranking) {
    if (ranking > 0) {
        return `#${ranking}`;
    }
    return '';
}

// Render the scoreboard
function renderScoreboard(match) {
    // Store match data for settings modal
    window.currentMatchData = match;

    // Update header info
    document.getElementById('matchNameDisplay').textContent = match.matchName || 'Tr칛ningsmatch';
    document.getElementById('matchCodeDisplay').textContent = match.matchCode;
    document.getElementById('matchWeaponClass').textContent = 'Klass ' + match.weaponClass;

    // Store match status for spectators display (hide for completed matches)
    window.currentMatchStatus = match.status || 'Active';

    // Show/hide handicap badge
    const handicapBadge = document.getElementById('handicapBadge');
    if (handicapBadge) {
        handicapBadge.style.display = match.hasHandicap ? 'inline-block' : 'none';
    }

    // Handle spectator mode
    const spectatorBanner = document.getElementById('spectatorBanner');
    const addScoreBtn = document.getElementById('addScoreBtn');
    const leaveBtn = document.getElementById('leaveMatchBtn');
    const endBtn = document.getElementById('endMatchBtn');
    const shareBtn = document.getElementById('shareMatchBtn');
    const exitSpectatorBtn = document.getElementById('exitSpectatorBtn');

    // Check if current user is actually in the participants list
    const myMemberIdCheck = parseInt(document.body.dataset.memberId) || 0;
    // For guests, check guestParticipantId instead of memberId
    const isActuallyParticipant = match.participants.some(p => {
        if (typeof isGuestUser !== 'undefined' && isGuestUser && typeof guestParticipantId !== 'undefined' && guestParticipantId > 0) {
            return p.guestParticipantId === guestParticipantId;
        }
        return p.memberId === myMemberIdCheck;
    });

    // Show/hide spectator banner - show if:
    // 1. Match is ACTIVE (not completed/history), AND
    // 2. User is explicitly spectator OR not in participants list
    const isMatchActive = match.status === 'Active';
    const isSpectatorMode = (typeof isSpectator !== 'undefined' && isSpectator === true) || !isActuallyParticipant;
    const shouldShowSpectatorBanner = isMatchActive && isSpectatorMode;

    if (shouldShowSpectatorBanner) {
        if (spectatorBanner) spectatorBanner.style.display = 'flex';
        if (addScoreBtn) addScoreBtn.style.display = 'none';
        if (leaveBtn) leaveBtn.style.display = 'none';
        if (endBtn) endBtn.style.display = 'none';
        if (exitSpectatorBtn) exitSpectatorBtn.style.display = 'inline-block';
    } else {
        if (spectatorBanner) spectatorBanner.style.display = 'none';
        // Only show add score button if match is active and user is participant
        if (addScoreBtn) addScoreBtn.style.display = isMatchActive && isActuallyParticipant ? 'block' : 'none';
        if (exitSpectatorBtn) exitSpectatorBtn.style.display = 'none';
    }

    // Handle scheduled match banners
    const scheduledBannerCreator = document.getElementById('scheduledMatchBannerCreator');
    const scheduledBannerParticipant = document.getElementById('scheduledMatchBannerParticipant');
    const myMemberIdForSchedule = parseInt(document.body.dataset.memberId) || 0;
    const isCreatorForSchedule = match.createdByMemberId === myMemberIdForSchedule;

    // Store match state globally for score button click handler
    window.currentMatchState = {
        hasStarted: match.hasStarted,
        isCreator: isCreatorForSchedule,
        startDate: match.startDate
    };

    // Debug logging
    console.log('Match state:', {
        hasStarted: match.hasStarted,
        startDate: match.startDate,
        isCreator: isCreatorForSchedule,
        myMemberId: myMemberIdForSchedule,
        createdByMemberId: match.createdByMemberId
    });

    // Clear any existing start timer
    if (window.matchStartTimer) {
        clearTimeout(window.matchStartTimer);
        window.matchStartTimer = null;
    }

    if (match.hasStarted === false) {
        const startTimeDate = new Date(match.startDate);
        const startTime = startTimeDate.toLocaleString('sv-SE', {
            weekday: 'short', month: 'short', day: 'numeric',
            hour: '2-digit', minute: '2-digit'
        });

        if (isCreatorForSchedule) {
            // Creator sees warning banner but can still add scores
            document.getElementById('scheduledStartTimeCreator').textContent = startTime;
            if (scheduledBannerCreator) scheduledBannerCreator.style.display = 'flex';
            if (scheduledBannerParticipant) scheduledBannerParticipant.style.display = 'none';
            // Creator can add scores, but non-creators cannot
            if (addScoreBtn) addScoreBtn.style.display = 'block';
        } else {
            // Non-creator participant sees info banner and cannot add scores
            document.getElementById('scheduledStartTimeParticipant').textContent = startTime;
            if (scheduledBannerCreator) scheduledBannerCreator.style.display = 'none';
            if (scheduledBannerParticipant) scheduledBannerParticipant.style.display = 'flex';
            // Keep button visible but it will show message on click
            if (addScoreBtn) addScoreBtn.style.display = 'block';
        }

        // Set timer to fire when match starts
        const msUntilStart = startTimeDate.getTime() - Date.now();
        if (msUntilStart > 0 && msUntilStart < 24 * 60 * 60 * 1000) {
            // Only set timer if start is within 24 hours (avoid very long timers)
            window.matchStartTimer = setTimeout(() => {
                // Update state
                if (window.currentMatchState) {
                    window.currentMatchState.hasStarted = true;
                }
                // Hide banners
                if (scheduledBannerCreator) scheduledBannerCreator.style.display = 'none';
                if (scheduledBannerParticipant) scheduledBannerParticipant.style.display = 'none';
                // Show notification
                if (typeof showToast === 'function') {
                    showToast('Matchen har startat! Du kan nu registrera resultat.', 'success');
                }
            }, msUntilStart);
            console.log('Match start timer set for', msUntilStart / 1000, 'seconds');
        }
    } else {
        if (scheduledBannerCreator) scheduledBannerCreator.style.display = 'none';
        if (scheduledBannerParticipant) scheduledBannerParticipant.style.display = 'none';
    }

    // Get current member ID from participants (the one with our email)
    const currentParticipant = match.participants.find(p =>
        document.body.dataset.memberEmail &&
        p.email === document.body.dataset.memberEmail
    );

    // Show/hide buttons based on participant status (only if not spectator)
    const settingsBtn = document.getElementById('matchSettingsBtn');
    // Note: shareBtn already declared above

    if (typeof isSpectator === 'undefined' || !isSpectator) {
        const myMemberId = parseInt(document.body.dataset.memberId) || 0;
        const isCreator = match.createdByMemberId === myMemberId;
        // For guests, check guestParticipantId instead of memberId
        const isParticipant = match.participants.some(p => {
            if (typeof isGuestUser !== 'undefined' && isGuestUser && typeof guestParticipantId !== 'undefined' && guestParticipantId > 0) {
                return p.guestParticipantId === guestParticipantId;
            }
            return p.memberId === myMemberId;
        });

        if (isCreator && match.status === 'Active') {
            // Creator sees settings button (cog) only
            if (settingsBtn) settingsBtn.style.display = 'inline-block';
            if (shareBtn) shareBtn.style.display = 'none';
            if (endBtn) endBtn.style.display = 'none'; // End is in settings modal
            if (leaveBtn) leaveBtn.style.display = 'none';
        } else if (isParticipant && match.status === 'Active') {
            // Participants see share and leave buttons
            if (settingsBtn) settingsBtn.style.display = 'none';
            if (shareBtn) shareBtn.style.display = 'inline-block';
            if (endBtn) endBtn.style.display = 'none';
            if (leaveBtn) leaveBtn.style.display = 'inline-block';
        } else {
            // Match completed or user is not participant
            if (settingsBtn) settingsBtn.style.display = 'none';
            if (shareBtn) shareBtn.style.display = match.status === 'Active' ? 'inline-block' : 'none';
            if (endBtn) endBtn.style.display = 'none';
            if (leaveBtn) leaveBtn.style.display = 'none';
        }
    } else {
        // Spectators - hide settings and creator buttons
        if (settingsBtn) settingsBtn.style.display = 'none';
    }

    // Calculate participant rankings for top 3 display
    const rankings = calculateParticipantRankings(match);

    // Build participant header row
    const headerRow = document.getElementById('participantHeaderRow');
    headerRow.innerHTML = '';

    match.participants.forEach((participant, index) => {
        const th = document.createElement('th');
        th.className = 'participant-column';

        // Build handicap info if match has handicap enabled
        let handicapInfo = '';
        if (match.hasHandicap && participant.handicapPerSeries !== null && participant.handicapPerSeries !== undefined) {
            const hcpDisplay = formatHandicap(participant.handicapPerSeries);
            const provisionalBadge = participant.isProvisional
                ? '<span class="provisional-badge" title="Provisoriskt handicap (f칛rre 칛n 8 matcher)">(P)</span>'
                : '';
            handicapInfo = `
                <div class="participant-handicap">
                    <span class="handicap-value">${hcpDisplay}</span>
                    ${provisionalBadge}
                </div>
            `;
        }

        // Build guest badge if participant is a guest
        const guestBadge = participant.isGuest
            ? '<span class="guest-badge" title="G칛st"><i class="bi bi-person-badge"></i></span>'
            : '';

        th.innerHTML = `
            <div class="participant-header">
                ${renderAvatar(participant)}
                <div class="participant-name">${participant.firstName || 'Skytt'}${guestBadge}</div>
                ${handicapInfo}
            </div>
        `;
        headerRow.appendChild(th);
    });

    // Find max series count
    let maxSeries = 0;
    match.participants.forEach(p => {
        if (p.scores && p.scores.length > maxSeries) {
            maxSeries = p.scores.length;
        }
    });

    // Always show at least 6 rows, or more if there are more series
    const displayRows = Math.max(6, maxSeries);

    // Build score rows
    const tbody = document.getElementById('scoreboardBody');
    tbody.innerHTML = '';

    // Track running totals for each participant
    const runningTotals = match.participants.map(() => 0);

    // Get current member's participant for identifying editable cells
    const myMemberId = document.body.dataset.memberId;

    for (let seriesNum = 1; seriesNum <= displayRows; seriesNum++) {
        const tr = document.createElement('tr');

        match.participants.forEach((participant, pIndex) => {
            const td = document.createElement('td');
            td.className = 'score-cell';

            // Add data attributes for reactions and photo viewing
            td.dataset.memberId = participant.memberId;
            td.dataset.series = seriesNum;

            const score = participant.scores?.find(s => s.seriesNumber === seriesNum);
            if (score) {
                // Cap each series at 50 (max possible score per series)
                const cappedTotal = Math.min(score.total, 50);
                runningTotals[pIndex] += cappedTotal;

                // Check if this is the current user's score (editable)
                // Never allow editing if spectator or match not started
                // For guests, check guestParticipantId instead of memberId
                const isMyScore = (myMemberId && participant.memberId == myMemberId) ||
                    (typeof isGuestUser !== 'undefined' && isGuestUser &&
                     typeof guestParticipantId !== 'undefined' && guestParticipantId > 0 &&
                     participant.guestParticipantId === guestParticipantId);
                const isFirstParticipantFallback = !myMemberId && pIndex === 0;
                const isSpectatorMode = typeof isSpectator !== 'undefined' && isSpectator;
                const matchHasStarted = match.hasStarted !== false;
                const canEdit = (isMyScore || isFirstParticipantFallback) && match.status === 'Active' && !isSpectatorMode && matchHasStarted;

                // Build inline reaction emoji (just the first emoji, inline with score)
                const inlineReaction = buildInlineReactionHtml(score.reactions);

                // Check if score has a target photo
                const hasPhoto = score.targetPhotoUrl && score.targetPhotoUrl.length > 0;
                const shooterName = participant.firstName || 'Skytt';
                const scoreJson = JSON.stringify(score).replace(/"/g, '&quot;');
                const photoIndicator = hasPhoto
                    ? `<i class="bi bi-camera-fill photo-indicator photo-clickable" title="Visa m친lfoto" onclick="event.stopPropagation(); showTargetPhotoModal(${seriesNum}, ${scoreJson}, '${shooterName}')"></i>`
                    : '';

                if (canEdit) {
                    td.innerHTML = `
                        ${photoIndicator}
                        <div class="score-editable" onclick="editSeriesScore(${seriesNum}, ${scoreJson})">
                            <span class="score-value">${cappedTotal}</span>${inlineReaction}
                            <i class="bi bi-pencil edit-icon"></i>
                        </div>
                        ${score.xCount > 0 ? `<span class="x-count">${score.xCount}x</span>` : ''}
                    `;
                    td.classList.add('has-score', 'editable');
                } else {
                    // Non-editable score - can click for reactions or photo viewing
                    td.innerHTML = `
                        ${photoIndicator}
                        <div class="score-clickable" onclick="handleScoreCellClick(event, ${participant.memberId}, ${seriesNum}, ${scoreJson})"
                             data-member-id="${participant.memberId}" data-series="${seriesNum}">
                            <span class="score-value">${cappedTotal}</span>${inlineReaction}
                        </div>
                        ${score.xCount > 0 ? `<span class="x-count">${score.xCount}x</span>` : ''}
                    `;
                    td.classList.add('has-score', 'clickable');
                }
            } else {
                td.innerHTML = '<span class="score-empty">-</span>';
            }

            tr.appendChild(td);
        });

        tbody.appendChild(tr);

        // Add summary row after series 6, 7, 10, and 12
        if (seriesNum === 6 || seriesNum === 7 || seriesNum === 10 || seriesNum === 12) {
            const summaryRow = document.createElement('tr');
            summaryRow.className = 'summary-row';

            match.participants.forEach((participant, pIndex) => {
                const td = document.createElement('td');
                td.className = 'summary-cell';

                // Calculate total up to this point (cap each series at 50)
                let totalToHere = 0;
                for (let s = 1; s <= seriesNum; s++) {
                    const score = participant.scores?.find(sc => sc.seriesNumber === s);
                    if (score) totalToHere += Math.min(score.total, 50);
                }

                td.innerHTML = `<strong>${totalToHere}</strong> <small class="text-muted">(${seriesNum})</small>`;
                summaryRow.appendChild(td);
            });

            tbody.appendChild(summaryRow);
        }
    }

    // Add final total row
    const totalRow = document.createElement('tr');
    totalRow.className = 'total-row';

    // Calculate minimum series count for equalized totals (fair comparison)
    const participantsWithScores = match.participants.filter(p => p.scores && p.scores.length > 0);
    const minSeriesCount = participantsWithScores.length > 0
        ? Math.min(...participantsWithScores.map(p => p.scores.length))
        : 0;

    match.participants.forEach(participant => {
        const td = document.createElement('td');
        td.className = 'total-cell';

        // Get ranking for this participant
        const participantKey = participant.memberId || `guest_${participant.guestParticipantId}`;
        const ranking = rankings[participantKey];
        const rankingColor = getRankingColor(ranking);
        const rankingText = getRankingText(ranking);

        // Determine effective series count for this participant
        const allScores = participant.scores || [];
        const actualSeriesCount = allScores.length;

        // If maxSeriesCount is set, use it as limit; otherwise use minimum among all participants
        let effectiveLimit;
        if (match.maxSeriesCount) {
            // Max is set - each participant limited to max or their actual, whichever is less
            effectiveLimit = Math.min(match.maxSeriesCount, actualSeriesCount);
        } else {
            // No max - use current minimum behavior
            effectiveLimit = Math.min(minSeriesCount, actualSeriesCount);
        }

        const effectiveScores = allScores
            .sort((a, b) => a.seriesNumber - b.seriesNumber)
            .slice(0, effectiveLimit);

        // Cap each series at 50 (max possible score per series)
        const totalScore = effectiveScores.reduce((sum, s) => sum + Math.min(s.total, 50), 0);
        const totalX = effectiveScores.reduce((sum, s) => sum + (s.xCount || 0), 0);
        const effectiveSeriesCount = effectiveScores.length;

        // Show "6/10 serier" format if participant has more series than minimum
        const seriesDisplay = actualSeriesCount > effectiveSeriesCount
            ? `${effectiveSeriesCount}/${actualSeriesCount} serier`
            : `${effectiveSeriesCount} serier`;

        // Build ranking indicator HTML for all participants
        const rankingIndicator = rankingText
            ? `<span class="ranking-indicator" style="color: ${rankingColor}; margin-left: 4px;">${rankingText}</span>`
            : '';

        // Check if handicap is enabled and participant has handicap data
        if (match.hasHandicap && participant.handicapPerSeries !== null && participant.handicapPerSeries !== undefined) {
            // Per-series handicap capping: each series adjusted and capped at 50
            const hcpPerSeries = roundToQuarter(participant.handicapPerSeries);
            const result = calculateAdjustedTotalWithCap(effectiveScores, hcpPerSeries);
            const finalScore = result.total;
            const hcpTotalDisplay = formatHandicap(result.effectiveHandicap);

            td.innerHTML = `
                <div class="total-score handicap-final">${finalScore}${rankingIndicator}</div>
                <div class="total-handicap-breakdown">
                    <span class="raw-score">${totalScore}</span>
                    <span class="hcp-addition">${hcpTotalDisplay}</span>
                </div>
                <div class="total-details">${seriesDisplay}${totalX > 0 ? ` | ${totalX}x` : ''}</div>
            `;
        } else {
            td.innerHTML = `
                <div class="total-score">${totalScore}${rankingIndicator}</div>
                <div class="total-details">${seriesDisplay}${totalX > 0 ? ` | ${totalX}x` : ''}</div>
            `;
        }
        totalRow.appendChild(td);
    });

    tbody.appendChild(totalRow);

    // Update responsive reaction displays after DOM is ready
    setTimeout(updateReactionDisplays, 50);
}

// Render avatar helper
function renderAvatar(participant) {
    if (participant.profilePictureUrl) {
        return `<img src="${participant.profilePictureUrl}" alt="${participant.firstName}"
                     class="participant-avatar">`;
    }

    const initials = ((participant.firstName?.[0] || '') + (participant.lastName?.[0] || '')).toUpperCase();
    return `<div class="participant-avatar participant-avatar-initials">${initials}</div>`;
}

// Handle add score button click - check if match has started for non-creators
function handleAddScoreClick() {
    const state = window.currentMatchState || {};

    // If match hasn't started and user is not the creator, show message
    if (state.hasStarted === false && !state.isCreator) {
        const startTime = new Date(state.startDate).toLocaleString('sv-SE', {
            weekday: 'short', month: 'short', day: 'numeric',
            hour: '2-digit', minute: '2-digit'
        });
        showToast(`Matchen har inte startat 칛nnu. Du kan registrera resultat efter ${startTime}.`, 'warning', 5000);
        return;
    }

    // Otherwise, open the score entry modal
    if (typeof openScoreEntryModal === 'function') {
        openScoreEntryModal();
    } else {
        console.error('openScoreEntryModal function not found');
    }
}

// Edit a series score - opens the edit modal
function editSeriesScore(seriesNumber, scoreData) {
    // The scoreData is passed as an object from the onclick handler
    if (typeof openScoreEditModal === 'function') {
        openScoreEditModal(seriesNumber, scoreData);
    } else {
        console.error('openScoreEditModal function not found');
    }
}

// Store current spectators list globally (filtered, excluding current user)
window.currentSpectators = [];
// Store current match status for spectators display
window.currentMatchStatus = 'Active';

// Update spectators display
function updateSpectatorsDisplay(spectators, matchStatus) {
    const display = document.getElementById('spectatorsDisplay');
    const avatarsContainer = document.getElementById('spectatorAvatars');
    const countBadge = document.getElementById('spectatorCount');

    if (!display || !avatarsContainer || !countBadge) return;

    // Update match status if provided
    if (matchStatus) {
        window.currentMatchStatus = matchStatus;
    }

    // Only show spectators for active matches, not completed/history
    if (window.currentMatchStatus !== 'Active') {
        display.style.display = 'none';
        display.style.setProperty('display', 'none', 'important');
        window.currentSpectators = [];
        return;
    }

    // Filter out the current user from spectators list
    const myMemberId = parseInt(document.body.dataset.memberId) || 0;
    const otherSpectators = (spectators || []).filter(s => s.memberId !== myMemberId);
    window.currentSpectators = otherSpectators;

    if (otherSpectators.length === 0) {
        display.style.display = 'none';
        display.style.setProperty('display', 'none', 'important');
        return;
    }

    // Show display
    display.style.display = 'flex';
    display.style.removeProperty('display');

    // Show up to 3 avatars
    const maxAvatars = 3;
    const visibleSpectators = otherSpectators.slice(0, maxAvatars);

    avatarsContainer.innerHTML = visibleSpectators.map(s => {
        if (s.profilePictureUrl) {
            return `<img src="${s.profilePictureUrl}" alt="${s.name}" class="spectator-mini-avatar" title="${s.name}">`;
        }
        const initials = s.name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
        return `<div class="spectator-mini-avatar spectator-mini-avatar-initials" title="${s.name}">${initials}</div>`;
    }).join('');

    // Update count
    countBadge.textContent = otherSpectators.length;
}

// Show spectators modal
function showSpectatorsModal() {
    const spectators = window.currentSpectators || [];
    const listContainer = document.getElementById('spectatorsList');
    const noMessage = document.getElementById('noSpectatorsMessage');

    if (spectators.length === 0) {
        listContainer.style.display = 'none';
        noMessage.style.display = 'block';
    } else {
        listContainer.style.display = 'block';
        noMessage.style.display = 'none';

        listContainer.innerHTML = spectators.map(s => {
            const avatar = s.profilePictureUrl
                ? `<img src="${s.profilePictureUrl}" alt="${s.name}" class="rounded-circle" style="width: 40px; height: 40px; object-fit: cover;">`
                : `<div class="rounded-circle bg-secondary text-white d-flex align-items-center justify-content-center" style="width: 40px; height: 40px; font-size: 14px;">${s.name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2)}</div>`;

            return `
                <div class="list-group-item d-flex align-items-center gap-3">
                    ${avatar}
                    <div>
                        <div class="fw-medium">${s.name}</div>
                        ${s.clubName ? `<small class="text-muted">${s.clubName}</small>` : ''}
                    </div>
                </div>
            `;
        }).join('');
    }

    const modal = new bootstrap.Modal(document.getElementById('spectatorsModal'));
    modal.show();
}

// Show target photo modal
function showTargetPhotoModal(seriesNumber, score, shooterName) {
    // Update modal content
    document.getElementById('photoSeriesNumber').textContent = seriesNumber;
    document.getElementById('photoScoreTotal').textContent = score.total || '-';
    document.getElementById('photoShooterName').textContent = shooterName || 'Skytt';

    const xCountContainer = document.getElementById('photoXCountContainer');
    if (score.xCount > 0) {
        document.getElementById('photoXCount').textContent = score.xCount + 'x';
        xCountContainer.style.display = 'block';
    } else {
        xCountContainer.style.display = 'none';
    }

    // Handle photo loading
    const loadingSpinner = document.getElementById('photoLoadingSpinner');
    const photoImage = document.getElementById('targetPhotoImage');
    const noPhotoMsg = document.getElementById('noPhotoMessage');

    if (score.targetPhotoUrl) {
        loadingSpinner.style.display = 'block';
        photoImage.style.display = 'none';
        noPhotoMsg.style.display = 'none';

        photoImage.onload = () => {
            loadingSpinner.style.display = 'none';
            photoImage.style.display = 'block';
        };
        photoImage.onerror = () => {
            loadingSpinner.style.display = 'none';
            noPhotoMsg.style.display = 'block';
        };
        photoImage.src = score.targetPhotoUrl;
    } else {
        loadingSpinner.style.display = 'none';
        photoImage.style.display = 'none';
        noPhotoMsg.style.display = 'block';
    }

    // Store current score data for reactions
    window.currentPhotoScore = score;
    window.currentPhotoMemberId = score.memberId;
    window.currentPhotoSeriesNumber = seriesNumber;

    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('targetPhotoModal'));
    modal.show();
}

// Show match settings modal (creator only)
function showMatchSettingsModal() {
    const match = window.currentMatchData;
    if (!match) return;

    // Populate the modal with current values
    const maxSeriesInput = document.getElementById('maxSeriesCountInput');
    const matchCodeDisplay = document.getElementById('settingsMatchCode');
    const qrCodeImg = document.getElementById('settingsQrCode');
    const matchLinkInput = document.getElementById('settingsMatchLink');

    if (maxSeriesInput) {
        maxSeriesInput.value = match.maxSeriesCount || '';
    }
    if (matchCodeDisplay) {
        matchCodeDisplay.textContent = match.matchCode || '';
    }
    if (qrCodeImg) {
        qrCodeImg.src = '/umbraco/surface/TrainingMatch/GetJoinQrCode?matchCode=' + match.matchCode;
    }
    if (matchLinkInput) {
        matchLinkInput.value = window.location.origin + '/traningsmatch/?join=' + match.matchCode;
    }

    // Reset QR code visibility (start hidden)
    const qrContainer = document.getElementById('settingsQrCodeContainer');
    if (qrContainer) {
        qrContainer.style.display = 'none';
    }

    // Show/hide guest management section (always show for organizers)
    const guestSection = document.getElementById('guestManagementSection');
    if (guestSection) {
        guestSection.style.display = 'block';
        // Initialize the add guest modal with current match data
        if (typeof initAddGuestModal === 'function') {
            initAddGuestModal(match.matchCode, match.hasHandicap || false);
        }
    }

    // Show member claim section (for members who forgot password)
    const memberClaimSection = document.getElementById('memberClaimSection');
    if (memberClaimSection) {
        memberClaimSection.style.display = 'block';
    }

    const modal = new bootstrap.Modal(document.getElementById('matchSettingsModal'));
    modal.show();
}

// Confirm and end match
function confirmEndMatch() {
    if (confirm('츿r du s칛ker p친 att du vill avsluta matchen? Detta kan inte 친ngras.')) {
        completeMatch();
        bootstrap.Modal.getInstance(document.getElementById('matchSettingsModal'))?.hide();
    }
}

// Toggle QR code visibility in settings modal
function toggleSettingsQrCode() {
    const container = document.getElementById('settingsQrCodeContainer');
    if (container) {
        container.style.display = container.style.display === 'none' ? 'block' : 'none';
    }
}

// Save match settings
async function saveMatchSettings() {
    const match = window.currentMatchData;
    if (!match) return;

    const maxSeriesInput = document.getElementById('maxSeriesCountInput');
    const maxSeriesCount = maxSeriesInput.value ? parseInt(maxSeriesInput.value) : null;

    try {
        const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;
        const response = await fetch('/umbraco/surface/TrainingMatch/UpdateMatchSettings', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'RequestVerificationToken': token
            },
            body: JSON.stringify({
                matchCode: match.matchCode,
                maxSeriesCount: maxSeriesCount
            })
        });

        const result = await response.json();
        if (result.success) {
            // Update local match data
            window.currentMatchData.maxSeriesCount = maxSeriesCount;
            // Re-render scoreboard to update totals
            renderScoreboard(window.currentMatchData);
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById('matchSettingsModal')).hide();
        } else {
            alert(result.message || 'Kunde inte spara inst칛llningar');
        }
    } catch (error) {
        console.error('Error saving settings:', error);
        alert('Ett fel uppstod vid sparning av inst칛llningar');
    }
}

// Copy match link from settings modal
function copyMatchLinkFromSettings() {
    const input = document.getElementById('settingsMatchLink');
    if (input) {
        navigator.clipboard.writeText(input.value).then(() => {
            // Show brief feedback on button
            const btn = input.nextElementSibling;
            const originalHtml = btn.innerHTML;
            btn.innerHTML = '<i class="bi bi-check"></i> Kopierad!';
            btn.classList.remove('btn-outline-primary');
            btn.classList.add('btn-success');
            setTimeout(() => {
                btn.innerHTML = originalHtml;
                btn.classList.remove('btn-success');
                btn.classList.add('btn-outline-primary');
            }, 2000);
        });
    }
}
</script>

<style>
/* Scoreboard Container */
.scoreboard-container {
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    overflow: hidden;
    margin-bottom: 80px; /* Space for floating button */
}

.scoreboard-scroll {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
}

/* Scoreboard Table */
.scoreboard-table {
    width: 100%;
    min-width: max-content;
    border-collapse: collapse;
    table-layout: fixed;
}

.scoreboard-table th,
.scoreboard-table td {
    min-width: 80px;
    text-align: center;
    padding: 8px 4px;
    border: 1px solid #dee2e6;
}

/* Participant Header */
.participant-column {
    background: #f8f9fa;
    padding: 12px 8px !important;
    position: sticky;
    top: 0;
    z-index: 10;
}

.participant-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}

.participant-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid #dee2e6;
}

.participant-avatar-initials {
    display: flex;
    align-items: center;
    justify-content: center;
    background: #6c757d;
    color: white;
    font-weight: bold;
    font-size: 1rem;
}

.participant-name {
    font-weight: 600;
    font-size: 0.9rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 80px;
}

/* Guest Badge */
.guest-badge {
    font-size: 0.7rem;
    color: #6c757d;
    margin-left: 2px;
    vertical-align: middle;
}

.guest-badge i {
    font-size: 0.8rem;
}

/* Handicap Display in Participant Header */
.participant-handicap {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    margin-top: 2px;
}

.handicap-value {
    font-size: 0.75rem;
    font-weight: 600;
    color: #198754;
    background: rgba(25, 135, 84, 0.1);
    padding: 1px 6px;
    border-radius: 10px;
}

.provisional-badge {
    font-size: 0.65rem;
    font-weight: bold;
    color: #fd7e14;
    cursor: help;
}

/* Score Cells */
.score-cell {
    font-size: 1.2rem;
    font-weight: 500;
    position: relative;
    height: 44px;
    vertical-align: middle;
}

.score-cell.has-score {
    background: #f0f9f0;
}

.score-cell.editable {
    cursor: pointer;
    transition: background-color 0.15s ease;
}

.score-cell.editable:hover {
    background: #d4edda;
}

.score-cell.editable:active {
    background: #c3e6cb;
}

.score-editable {
    position: relative;
    display: inline-block;
    width: 100%;
    height: 100%;
}

.score-editable .edit-icon {
    position: absolute;
    bottom: 2px;
    right: 4px;
    font-size: 0.65rem;
    color: #6c757d;
    opacity: 0;
    transition: opacity 0.15s ease;
}

.score-cell.editable:hover .edit-icon,
.score-cell.editable:focus .edit-icon {
    opacity: 1;
}

/* Always show edit icon on touch devices */
@@media (hover: none) {
    .score-editable .edit-icon {
        opacity: 0.5;
    }
}

.score-value {
    font-weight: 600;
}

.score-empty {
    color: #ccc;
}

.x-count {
    font-size: 0.7rem;
    color: #ffc107;
    font-weight: bold;
    position: absolute;
    top: 2px;
    right: 4px;
}

/* Summary Rows */
.summary-row {
    background: #e9ecef !important;
}

.summary-cell {
    font-size: 1rem;
    padding: 6px 4px !important;
}

/* Total Row */
.total-row {
    background: #343a40 !important;
    color: white;
}

.total-cell {
    padding: 12px 4px !important;
}

.total-score {
    font-size: 1.5rem;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
}

/* Ranking Indicator for Top 3 */
.ranking-indicator {
    font-size: 1rem;
    font-weight: bold;
}

.total-details {
    font-size: 0.75rem;
    opacity: 0.8;
}

/* Handicap Total Display */
.total-score.handicap-final {
    color: #ffc107;
}

.total-handicap-breakdown {
    display: flex;
    justify-content: center;
    gap: 4px;
    font-size: 0.8rem;
    margin-top: 2px;
}

.total-handicap-breakdown .raw-score {
    opacity: 0.7;
}

.total-handicap-breakdown .hcp-addition {
    color: #90EE90;
    font-weight: 500;
}

/* Mobile Responsive */
@@media (max-width: 576px) {
    .scoreboard-table th,
    .scoreboard-table td {
        min-width: 70px;
        padding: 6px 2px;
    }

    .participant-avatar {
        width: 40px;
        height: 40px;
    }

    .participant-name {
        font-size: 0.8rem;
        max-width: 70px;
    }

    .score-cell {
        font-size: 1rem;
        height: 40px;
    }

    .total-score {
        font-size: 1.2rem;
    }

    /* Floating button smaller on mobile */
    #addScoreBtn {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
    }
}

/* Landscape optimization for more columns */
@@media (min-width: 768px) and (orientation: landscape) {
    .scoreboard-table th,
    .scoreboard-table td {
        min-width: 90px;
    }
}

/* Dark Mode Support */
[data-bs-theme="dark"] .scoreboard-container {
    background: #212529;
}

[data-bs-theme="dark"] .scoreboard-table th,
[data-bs-theme="dark"] .scoreboard-table td {
    border-color: #495057;
    color: #e9ecef;
}

[data-bs-theme="dark"] .participant-column {
    background: #343a40;
}

[data-bs-theme="dark"] .participant-avatar {
    border-color: #6c757d;
}

[data-bs-theme="dark"] .score-cell {
    background: #2b3035;
}

[data-bs-theme="dark"] .score-cell.has-score {
    background: #1a3a1a;
}

[data-bs-theme="dark"] .score-cell.editable:hover {
    background: #2a4a2a;
}

[data-bs-theme="dark"] .score-cell.editable:active {
    background: #3a5a3a;
}

[data-bs-theme="dark"] .score-editable .edit-icon {
    color: #adb5bd;
}

[data-bs-theme="dark"] .score-empty {
    color: #6c757d;
}

[data-bs-theme="dark"] .summary-row {
    background: #495057 !important;
}

[data-bs-theme="dark"] .summary-cell {
    color: #e9ecef;
}

[data-bs-theme="dark"] .summary-cell .text-muted {
    color: #adb5bd !important;
}

[data-bs-theme="dark"] .total-row {
    background: #0d6efd !important;
}

/* Dark Mode Handicap Styles */
[data-bs-theme="dark"] .handicap-value {
    color: #75b798;
    background: rgba(117, 183, 152, 0.15);
}

[data-bs-theme="dark"] .provisional-badge {
    color: #ffb74d;
}

[data-bs-theme="dark"] .total-score.handicap-final {
    color: #ffd54f;
}

[data-bs-theme="dark"] .total-handicap-breakdown .hcp-addition {
    color: #a5d6a7;
}

/* Spectator Mini Avatars */
.spectator-mini-avatar {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid rgba(255,255,255,0.8);
    margin-left: -8px;
}

.spectator-mini-avatar:first-child {
    margin-left: 0;
}

.spectator-mini-avatar-initials {
    display: flex;
    align-items: center;
    justify-content: center;
    background: #6c757d;
    color: white;
    font-weight: bold;
    font-size: 0.6rem;
}

#spectatorsDisplay {
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 20px;
    background: rgba(255,255,255,0.15);
    transition: background 0.2s;
}

#spectatorsDisplay:hover {
    background: rgba(255,255,255,0.25);
}

/* ===== Emoji Reactions & Photo Viewer ===== */

/* Inline Reaction (after score) */
.inline-reaction {
    font-size: 1rem;
    margin-left: 4px;
    vertical-align: middle;
}

/* Responsive Reaction Display */
.reaction-display {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    cursor: pointer;
    margin-left: 4px;
    vertical-align: middle;
}

.reaction-display:hover {
    opacity: 0.8;
}

.reaction-emoji {
    font-size: 0.85rem;
}

.reaction-grouped {
    font-size: 0.8rem;
    background: rgba(0,0,0,0.1);
    border-radius: 10px;
    padding: 0 4px;
}

.reaction-compact {
    font-size: 0.85rem;
}

[data-bs-theme="dark"] .reaction-grouped {
    background: rgba(255,255,255,0.15);
}

/* Photo Indicator (left side of cell) */
.photo-indicator {
    font-size: 1.1rem;
    color: #17a2b8;
    position: absolute;
    left: 8px;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0.85;
}

.photo-indicator.photo-clickable {
    cursor: pointer;
    z-index: 10;
}

.photo-indicator.photo-clickable:hover {
    opacity: 1;
    color: #138496;
    transform: translateY(-50%) scale(1.1);
}

/* Make score cells position relative for photo indicator */
.score-cell {
    position: relative;
}

/* Emoji Picker Popup */
.emoji-picker {
    position: fixed;
    background: var(--bs-body-bg);
    border: 1px solid var(--bs-border-color);
    border-radius: 12px;
    padding: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1050;
}

.emoji-picker-content {
    display: flex;
    gap: 4px;
}

.emoji-btn {
    background: none;
    border: none;
    font-size: 1.5rem;
    padding: 6px 8px;
    cursor: pointer;
    border-radius: 8px;
    transition: background-color 0.15s, transform 0.1s;
}

.emoji-btn:hover {
    background: var(--bs-tertiary-bg);
    transform: scale(1.15);
}

.emoji-btn.selected {
    background: var(--bs-primary);
    opacity: 0.8;
}

/* Clickable score cells (for reactions/photos) */
.score-cell.clickable {
    cursor: pointer;
    transition: background-color 0.15s ease;
}

.score-cell.clickable:hover {
    background: #e8f4f8 !important;
}

.score-cell.clickable:active {
    background: #d1ecf1 !important;
}

.score-clickable {
    position: relative;
    display: inline-block;
    width: 100%;
    height: 100%;
}

/* Photo modal emoji row */
.emoji-reaction-row {
    display: flex;
    align-items: center;
    gap: 4px;
}

.emoji-modal-btn {
    font-size: 1.2rem;
    padding: 4px 8px;
    border-radius: 8px;
}

.emoji-modal-btn.active {
    background-color: var(--bs-primary);
    border-color: var(--bs-primary);
    color: white;
}

/* Dark Mode for Emoji/Photo Features */
[data-bs-theme="dark"] .emoji-picker {
    background: #2b3035;
    border-color: #495057;
}

[data-bs-theme="dark"] .emoji-btn:hover {
    background: #495057;
}

[data-bs-theme="dark"] .score-cell.clickable:hover {
    background: #1a3a3a !important;
}

[data-bs-theme="dark"] .score-cell.clickable:active {
    background: #2a4a4a !important;
}

[data-bs-theme="dark"] .photo-indicator {
    color: #5bc0de;
}

[data-bs-theme="dark"] #photoScoreInfo {
    background: #343a40 !important;
}
</style>
