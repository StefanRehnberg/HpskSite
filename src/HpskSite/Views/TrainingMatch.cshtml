@using Umbraco.Cms.Core.Security
@using Umbraco.Cms.Core.Services
@using HpskSite.Services
@inject IMemberManager MemberManager
@inject IMemberService MemberService
@inject IMemberGroupService MemberGroupService
@inject ClubService ClubService
@inherits Umbraco.Cms.Web.Common.Views.UmbracoViewPage
@{
    Layout = "Master.cshtml";
    ViewBag.Title = "Tr칛ningsmatch";

    var currentMember = await MemberManager.GetCurrentMemberAsync();
    var isLoggedIn = currentMember != null;
    var isAdmin = false;

    // Get member data for identifying own scores and spectator registration
    int? memberId = null;
    string memberName = "";
    string profilePictureUrl = "";
    string clubName = "";

    if (isLoggedIn && currentMember != null)
    {
        var member = MemberService.GetByEmail(currentMember.Email ?? string.Empty);
        memberId = member?.Id;

        if (member != null)
        {
            var firstName = member.GetValue<string>("firstName") ?? "";
            var lastName = member.GetValue<string>("lastName") ?? "";
            memberName = $"{firstName} {lastName}".Trim();
            profilePictureUrl = member.GetValue<string>("profilePictureUrl") ?? "";

            // Look up primary club name using ClubService
            var primaryClubId = member.GetValue<int>("primaryClubId");
            if (primaryClubId > 0)
            {
                clubName = ClubService.GetClubNameById(primaryClubId) ?? "";
            }

            // Check if user is administrator
            var adminGroup = MemberGroupService.GetByName("Administrators");
            if (adminGroup != null)
            {
                var memberGroups = MemberService.GetAllRoles(member.Id);
                isAdmin = memberGroups.Contains("Administrators");
            }
        }
    }

    // Check for join code in URL
    var joinCode = Context.Request.Query["join"].ToString();
}

<div class="container py-4">
    @if (!isLoggedIn)
    {
        <!-- Not logged in message -->
        <div class="row justify-content-center">
            <div class="col-md-8">
                <div class="card border-primary">
                    <div class="card-header bg-primary text-white">
                        <h4 class="mb-0"><i class="bi bi-people-fill me-2"></i>Tr칛ningsmatch</h4>
                    </div>
                    <div class="card-body text-center py-5">
                        <i class="bi bi-lock-fill display-1 text-muted mb-3"></i>
                        <h5>Du m친ste vara inloggad</h5>
                        <p class="text-muted">Logga in f칬r att skapa eller g친 med i en tr칛ningsmatch.</p>
                        <a href="/login-register/?returnUrl=@Uri.EscapeDataString(Context.Request.Path + Context.Request.QueryString)" class="btn btn-primary">
                            <i class="bi bi-box-arrow-in-right me-1"></i> Logga in
                        </a>
                    </div>
                </div>
            </div>
        </div>
    }
    else
    {
        <!-- Main content for logged-in users -->
        <!-- Navigation Tabs -->
        <ul class="nav nav-tabs mb-4" id="matchTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="current-tab" data-bs-toggle="tab" data-bs-target="#currentTabContent"
                        type="button" role="tab" aria-controls="currentTabContent" aria-selected="true">
                    <i class="bi bi-bullseye me-1"></i>Aktuell match
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="ongoing-tab" data-bs-toggle="tab" data-bs-target="#ongoingTabContent"
                        type="button" role="tab" aria-controls="ongoingTabContent" aria-selected="false"
                        onclick="loadOngoingMatchesIfNeeded()">
                    <i class="bi bi-play-circle me-1"></i>P친g친ende
                    <span class="badge bg-primary ms-1" id="ongoingMatchCount" style="display: none;">0</span>
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="upcoming-tab" data-bs-toggle="tab" data-bs-target="#upcomingTabContent"
                        type="button" role="tab" aria-controls="upcomingTabContent" aria-selected="false"
                        onclick="loadUpcomingMatchesIfNeeded()">
                    <i class="bi bi-calendar-event me-1"></i>Kommande
                    <span class="badge bg-info ms-1" id="upcomingMatchCount" style="display: none;">0</span>
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="history-tab" data-bs-toggle="tab" data-bs-target="#historyTabContent"
                        type="button" role="tab" aria-controls="historyTabContent" aria-selected="false"
                        onclick="loadMatchHistoryIfNeeded()">
                    <i class="bi bi-clock-history me-1"></i>Historik
                </button>
            </li>
        </ul>

        <!-- Tab Content -->
        <div class="tab-content" id="matchTabsContent">
            <!-- Current Match Tab -->
            <div class="tab-pane fade show active" id="currentTabContent" role="tabpanel" aria-labelledby="current-tab">
                <div id="matchContainer">
                    <!-- Loading state -->
                    <div id="loadingState" class="text-center py-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Laddar...</span>
                        </div>
                        <p class="mt-3">Laddar...</p>
                    </div>

                    <!-- No match state - Create/Join -->
                    <div id="noMatchState" style="display: none;">
                        @await Html.PartialAsync("TrainingMatchCreate")
                        @await Html.PartialAsync("TrainingMatchJoin")
                    </div>

                    <!-- Active match state - Scoreboard -->
                    <div id="activeMatchState" style="display: none;">
                        @await Html.PartialAsync("TrainingMatchScoreboard")
                    </div>
                </div>
            </div>

            <!-- Ongoing Matches Tab -->
            <div class="tab-pane fade" id="ongoingTabContent" role="tabpanel" aria-labelledby="ongoing-tab">
                @await Html.PartialAsync("TrainingMatchOngoing")
            </div>

            <!-- Upcoming Matches Tab -->
            <div class="tab-pane fade" id="upcomingTabContent" role="tabpanel" aria-labelledby="upcoming-tab">
                @await Html.PartialAsync("TrainingMatchUpcoming")
            </div>

            <!-- History Tab -->
            <div class="tab-pane fade" id="historyTabContent" role="tabpanel" aria-labelledby="history-tab">
                @await Html.PartialAsync("TrainingMatchHistory")
            </div>
        </div>

        <!-- Android App Install Section -->
        <div id="android-app" class="card mt-4 border-success">
            <div class="card-body text-center py-4">
                <div class="mb-3">
                    <i class="bi bi-phone text-success" style="font-size: 2.5rem;"></i>
                </div>
                <h5 class="card-title">Tr칛ningsmatch finns som app!</h5>
                <p class="card-text text-muted mb-3">
                    Ladda ner Android-appen f칬r att enkelt rapportera resultat direkt fr친n skjutbanan.
                </p>
                <button type="button" class="btn btn-success" data-bs-toggle="modal" data-bs-target="#androidAppModal">
                    <i class="bi bi-android2 me-2"></i>H칛mta Android-appen
                </button>
            </div>
        </div>
    }
</div>

<!-- Android App Modal -->
@if (isLoggedIn)
{
    <div class="modal fade" id="androidAppModal" tabindex="-1" aria-labelledby="androidAppModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header bg-success text-white">
                    <h5 class="modal-title" id="androidAppModalLabel">
                        <i class="bi bi-android2 me-2"></i>HPSK Tr칛ningsmatch - Android App
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning mb-3">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <strong>Testversion</strong>
                    </div>
                    <p>
                        Appen 칛r f칬r n칛rvarande i <strong>slutet testfas</strong> och finns tillg칛nglig via Google Play f칬r inbjudna testare.
                    </p>
                    <p>
                        F칬r att delta i testet beh칬ver din e-postadress (<strong>@currentMember?.Email</strong>) vara registrerad som testare.
                    </p>
                    <p class="mb-0">
                        Klicka p친 knappen nedan f칬r att skicka en f칬rfr친gan om att bli testare.
                        Du f친r ett e-postmeddelande n칛r du har lagts till.
                    </p>
                    <p>
                        Eller installera direkt fr친n Play Store om du redan 칛r testare.
                    </p>
                </div>
                <div class="modal-footer justify-content-between">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Avbryt</button>
                    <div>
                        <button type="button" class="btn btn-outline-success me-2" id="requestTestAccessBtn" onclick="requestAndroidTestAccess()">
                            <i class="bi bi-send me-2"></i>Skicka f칬rfr친gan
                        </button>
                        <a href="https://play.google.com/apps/internaltest/4701079081567443484" target="_blank" class="btn btn-success">
                            <i class="bi bi-google-play me-2"></i>칐ppna i Play Store
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

<!-- Score Entry Modal -->
@await Html.PartialAsync("TrainingMatchScoreEntry")

<!-- SignalR Client Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>

@if (isLoggedIn)
{
    <script>
        // Global state
        let currentMatchCode = null;
        let currentMatch = null;
        let currentMemberId = @(memberId ?? 0);
        let isCurrentUserAdmin = @(isAdmin ? "true" : "false");
        let isSpectator = false;
        let hubConnection = null;

        // Set member data on body for other scripts to access
        document.body.dataset.memberId = '@(memberId ?? 0)';
        document.body.dataset.memberName = '@Html.Raw(memberName.Replace("'", "\\'"))';
        document.body.dataset.profilePictureUrl = '@Html.Raw(profilePictureUrl.Replace("'", "\\'"))';
        document.body.dataset.clubName = '@Html.Raw(clubName.Replace("'", "\\'"))';

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Run auto-close in background (don't block UI)
            autoCloseStaleMatches();

            // Load badge counts in parallel (non-blocking)
            loadBadgeCounts();

            // Check for join code in URL
            const urlParams = new URLSearchParams(window.location.search);
            const joinCode = urlParams.get('join');

            if (joinCode) {
                // Try to join the match
                joinMatchByCode(joinCode);
            } else {
                // Check for active matches immediately
                checkActiveMatches();
            }
        });

        // Check if user has any active matches
        function checkActiveMatches() {
            // Show loading state to clear previous view
            showLoading();

            fetch('/umbraco/surface/TrainingMatch/GetMyActiveMatches')
                .then(response => response.json())
                .then(result => {
                    hideLoading();

                    if (result.success) {
                        // Refresh member ID from server response to keep client in sync
                        if (result.currentMemberId !== null && result.currentMemberId !== undefined) {
                            if (currentMemberId !== result.currentMemberId) {
                                console.log(`Member ID refreshed: ${currentMemberId} -> ${result.currentMemberId}`);
                            }
                            currentMemberId = result.currentMemberId;
                            document.body.dataset.memberId = result.currentMemberId;
                        }

                        if (result.matches && result.matches.length > 0) {
                            // Show most recent active match
                            const latestMatch = result.matches[0];
                            loadMatch(latestMatch.matchCode);
                        } else {
                            // No active matches - show create/join
                            showNoMatchState();
                        }
                    } else {
                        // No active matches - show create/join
                        showNoMatchState();
                    }
                })
                .catch(error => {
                    console.error('Error checking active matches:', error);
                    hideLoading();
                    showNoMatchState();
                });
        }

        // Store pending match code for after shooter class is set
        let pendingJoinMatchCode = null;

        // Join match by code
        async function joinMatchByCode(code) {
            console.log('joinMatchByCode called with code:', code);
            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;

            try {
                const response = await fetch('/umbraco/surface/TrainingMatch/JoinMatch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': token || ''
                    },
                    body: JSON.stringify({ matchCode: code })
                });
                const result = await response.json();

                if (result.success) {
                    // Unregister as spectator first (wait for it to complete)
                    await unregisterAsSpectator(code);
                    // Clear URL parameter and load match
                    window.history.replaceState({}, '', window.location.pathname);
                    // Switch to "Aktuell match" tab
                    const currentTab = document.getElementById('current-tab');
                    if (currentTab) {
                        const tab = new bootstrap.Tab(currentTab);
                        tab.show();
                    }
                    loadMatch(code);
                } else if (result.needsShooterClass) {
                    // User needs to set their shooter class before joining handicap match
                    pendingJoinMatchCode = code;
                    showShooterClassModal();
                } else {
                    alert(result.message || 'Kunde inte g친 med i matchen');
                    hideLoading();
                    showNoMatchState();
                }
            } catch (error) {
                console.error('Error joining match:', error);
                alert('N친got gick fel vid anslutning till matchen');
                hideLoading();
                showNoMatchState();
            }
        }

        // Show shooter class selection modal
        function showShooterClassModal() {
            const modal = new bootstrap.Modal(document.getElementById('shooterClassModal'));
            modal.show();
        }

        // Save shooter class and retry joining match
        async function saveShooterClassAndJoin() {
            const selectedClass = document.querySelector('input[name="shooterClassRadio"]:checked')?.value;
            if (!selectedClass) {
                alert('V칛lj en skytteklass');
                return;
            }

            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;
            const saveBtn = document.getElementById('saveShooterClassBtn');
            const originalText = saveBtn.innerHTML;
            saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Sparar...';
            saveBtn.disabled = true;

            try {
                const response = await fetch('/umbraco/surface/TrainingMatch/SetShooterClass', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': token || ''
                    },
                    body: JSON.stringify({ shooterClass: selectedClass })
                });
                const result = await response.json();

                if (result.success) {
                    // Close modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('shooterClassModal'));
                    modal.hide();

                    // Now retry joining the match
                    if (pendingJoinMatchCode) {
                        showToast('Skytteklass sparad! Ansluter till matchen...', 'success');
                        setTimeout(() => {
                            joinMatchByCode(pendingJoinMatchCode);
                            pendingJoinMatchCode = null;
                        }, 500);
                    }
                } else {
                    alert(result.message || 'Kunde inte spara skytteklass');
                }
            } catch (error) {
                console.error('Error saving shooter class:', error);
                alert('N친got gick fel vid sparande av skytteklass');
            } finally {
                saveBtn.innerHTML = originalText;
                saveBtn.disabled = false;
            }
        }

        // Load match data
        function loadMatch(matchCode) {
            showLoading();
            currentMatchCode = matchCode;
            isSpectator = false; // Reset spectator mode when loading a match normally

            fetch(`/umbraco/surface/TrainingMatch/GetMatch?matchCode=${matchCode}`)
                .then(response => response.json())
                .then(result => {
                    hideLoading();

                    if (result.success) {
                        // Refresh member ID from server response to keep client in sync
                        // This MUST happen BEFORE the creator check below!
                        if (result.currentMemberId !== null && result.currentMemberId !== undefined) {
                            if (currentMemberId !== result.currentMemberId) {
                                console.log(`Member ID refreshed: ${currentMemberId} -> ${result.currentMemberId}`);
                            }
                            currentMemberId = result.currentMemberId;
                            document.body.dataset.memberId = result.currentMemberId;
                        }

                        currentMatch = result.match;
                        showActiveMatchState();
                        renderScoreboard(result.match);

                        // Join SignalR groups
                        joinMatchSignalRGroup(matchCode);

                        // If user is the creator, join organizer group for join request notifications
                        const myMemberId = parseInt(document.body.dataset.memberId) || 0;
                        if (result.match.createdByMemberId === myMemberId) {
                            joinOrganizerSignalRGroup(matchCode);
                            loadPendingJoinRequests(matchCode);
                        }
                    } else {
                        alert(result.message || 'Kunde inte ladda matchen');
                        showNoMatchState();
                    }
                })
                .catch(error => {
                    console.error('Error loading match:', error);
                    hideLoading();
                    alert('N친got gick fel vid laddning av matchen');
                    showNoMatchState();
                });
        }

        // Refresh current match
        function refreshMatch() {
            if (currentMatchCode) {
                loadMatch(currentMatchCode);
            }
        }

        // UI State functions
        function showLoading() {
            document.getElementById('loadingState').style.display = 'block';
            document.getElementById('noMatchState').style.display = 'none';
            document.getElementById('activeMatchState').style.display = 'none';
            // Hide the floating add score button
            const addScoreBtn = document.getElementById('addScoreBtn');
            if (addScoreBtn) addScoreBtn.style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loadingState').style.display = 'none';
        }

        function showNoMatchState() {
            document.getElementById('noMatchState').style.display = 'block';
            document.getElementById('activeMatchState').style.display = 'none';
            // Hide the floating add score button
            const addScoreBtn = document.getElementById('addScoreBtn');
            if (addScoreBtn) addScoreBtn.style.display = 'none';
        }

        function showActiveMatchState() {
            document.getElementById('noMatchState').style.display = 'none';
            document.getElementById('activeMatchState').style.display = 'block';
        }

        // Create new match
        // Store pending create match data for after shooter class is set
        let pendingCreateMatchData = null;

        function createMatch(matchName, weaponClass, startDate, isOpen = true, hasHandicap = false) {
            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;

            fetch('/umbraco/surface/TrainingMatch/CreateMatch', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': token || ''
                },
                body: JSON.stringify({
                    matchName: matchName,
                    weaponClass: weaponClass,
                    startDate: startDate,
                    isOpen: isOpen,
                    hasHandicap: hasHandicap
                })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    loadMatch(result.matchCode);
                } else if (result.needsShooterClass) {
                    // User needs to set their shooter class before creating handicap match
                    pendingCreateMatchData = { matchName, weaponClass, startDate, isOpen, hasHandicap };
                    showShooterClassModalForCreate();
                } else {
                    alert(result.message || 'Kunde inte skapa matchen');
                }
            })
            .catch(error => {
                console.error('Error creating match:', error);
                alert('N친got gick fel vid skapande av matchen');
            });
        }

        // Show shooter class modal for creating a match
        function showShooterClassModalForCreate() {
            // Update modal to use create handler
            const saveBtn = document.getElementById('saveShooterClassBtn');
            saveBtn.onclick = saveShooterClassAndCreate;
            showShooterClassModal();
        }

        // Save shooter class and retry creating match
        async function saveShooterClassAndCreate() {
            const selectedClass = document.querySelector('input[name="shooterClassRadio"]:checked')?.value;
            if (!selectedClass) {
                alert('V칛lj en skytteklass');
                return;
            }

            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;
            const saveBtn = document.getElementById('saveShooterClassBtn');
            const originalText = saveBtn.innerHTML;
            saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Sparar...';
            saveBtn.disabled = true;

            try {
                const response = await fetch('/umbraco/surface/TrainingMatch/SetShooterClass', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': token || ''
                    },
                    body: JSON.stringify({ shooterClass: selectedClass })
                });
                const result = await response.json();

                if (result.success) {
                    // Close modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('shooterClassModal'));
                    modal.hide();

                    // Reset button handler to default
                    saveBtn.onclick = saveShooterClassAndJoin;

                    // Now retry creating the match
                    if (pendingCreateMatchData) {
                        showToast('Skytteklass sparad! Skapar matchen...', 'success');
                        setTimeout(() => {
                            createMatch(
                                pendingCreateMatchData.matchName,
                                pendingCreateMatchData.weaponClass,
                                pendingCreateMatchData.startDate,
                                pendingCreateMatchData.isOpen,
                                pendingCreateMatchData.hasHandicap
                            );
                            pendingCreateMatchData = null;
                        }, 500);
                    }
                } else {
                    alert(result.message || 'Kunde inte spara skytteklass');
                }
            } catch (error) {
                console.error('Error saving shooter class:', error);
                alert('N친got gick fel vid sparande av skytteklass');
            } finally {
                saveBtn.innerHTML = originalText;
                saveBtn.disabled = false;
            }
        }

        // Leave current match
        function leaveMatch() {
            if (!currentMatchCode) return;

            if (!confirm('츿r du s칛ker p친 att du vill l칛mna matchen? Dina resultat kommer att tas bort.')) {
                return;
            }

            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;

            fetch('/umbraco/surface/TrainingMatch/LeaveMatch', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': token || ''
                },
                body: JSON.stringify({ matchCode: currentMatchCode })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    currentMatchCode = null;
                    currentMatch = null;
                    // Reload the tab to check for active matches
                    checkActiveMatches();
                } else {
                    alert(result.message || 'Kunde inte l칛mna matchen');
                }
            })
            .catch(error => {
                console.error('Error leaving match:', error);
                alert('N친got gick fel');
            });
        }

        // Exit spectator mode (for viewers who want to go back)
        async function exitSpectatorMode() {
            if (currentMatchCode) {
                // Unregister as spectator
                await unregisterAsSpectator(currentMatchCode);
            }

            // Reset state
            currentMatchCode = null;
            currentMatch = null;
            isSpectator = false;

            // Reload the tab to check for active matches
            checkActiveMatches();
        }

        // Complete/end match
        function completeMatch() {
            if (!currentMatchCode) return;

            if (!confirm('츿r du s칛ker p친 att du vill avsluta matchen? Detta kan inte 친ngras.')) {
                return;
            }

            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;

            fetch('/umbraco/surface/TrainingMatch/CompleteMatch', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': token || ''
                },
                body: JSON.stringify({ matchCode: currentMatchCode })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    alert('Matchen har avslutats!');
                    currentMatchCode = null;
                    currentMatch = null;
                    // Refresh ongoing matches list and badge immediately
                    ongoingMatchesLoaded = false;
                    loadOngoingMatches();
                    showNoMatchState();
                } else {
                    alert(result.message || 'Kunde inte avsluta matchen');
                }
            })
            .catch(error => {
                console.error('Error completing match:', error);
                alert('N친got gick fel');
            });
        }

        // Stop match from list (Ongoing tab)
        function stopMatchFromList(matchCode, matchName) {
            if (!confirm(`Avsluta "${matchName}"?\n\nMatchen kommer att avslutas och flyttas till historiken.`)) {
                return;
            }

            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;

            fetch('/umbraco/surface/TrainingMatch/CompleteMatch', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': token || ''
                },
                body: JSON.stringify({ matchCode: matchCode })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    showToast('Matchen har avslutats', 'success');
                    // Refresh ongoing matches list
                    ongoingMatchesLoaded = false;
                    loadOngoingMatches();
                    loadBadgeCounts();
                } else {
                    alert(result.message || 'Kunde inte avsluta matchen');
                }
            })
            .catch(error => {
                console.error('Error stopping match:', error);
                alert('N친got gick fel');
            });
        }

        // Delete match from list (Upcoming tab)
        function deleteMatchFromList(matchCode, matchName) {
            if (!confirm(`Radera "${matchName}"?\n\nMatchen och alla anm칛lningar tas bort permanent.`)) {
                return;
            }

            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;

            fetch('/umbraco/surface/TrainingMatch/DeleteMatch', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': token || ''
                },
                body: JSON.stringify({ matchCode: matchCode })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    showToast('Matchen har raderats', 'success');
                    // Refresh upcoming matches list
                    upcomingMatchesLoaded = false;
                    loadUpcomingMatches();
                    loadBadgeCounts();
                } else {
                    alert(result.message || 'Kunde inte radera matchen');
                }
            })
            .catch(error => {
                console.error('Error deleting match:', error);
                alert('N친got gick fel');
            });
        }

        // Show share modal
        function showShareModal() {
            if (!currentMatchCode) return;

            const modal = new bootstrap.Modal(document.getElementById('shareMatchModal'));

            // Update share info
            document.getElementById('shareMatchCode').textContent = currentMatchCode;
            document.getElementById('shareMatchLink').value = window.location.origin + '/traningsmatch/?join=' + currentMatchCode;

            // Load QR code
            document.getElementById('shareQrCode').src = '/umbraco/surface/TrainingMatch/GetJoinQrCode?matchCode=' + currentMatchCode;

            modal.show();
        }

        // Copy link to clipboard
        function copyShareLink() {
            const linkInput = document.getElementById('shareMatchLink');
            linkInput.select();
            document.execCommand('copy');

            // Show feedback
            const btn = document.querySelector('#shareMatchModal .btn-outline-primary');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="bi bi-check"></i> Kopierad!';
            btn.classList.remove('btn-outline-primary');
            btn.classList.add('btn-success');

            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.classList.remove('btn-success');
                btn.classList.add('btn-outline-primary');
            }, 2000);
        }

        // Match History functions
        let matchHistoryLoaded = false;

        function loadMatchHistoryIfNeeded() {
            if (!matchHistoryLoaded) {
                loadMatchHistory();
            }
        }

        // loadMatchHistory is defined in TrainingMatchHistory.cshtml partial

        // View a completed match in modal (read-only)
        function viewCompletedMatch(matchCode) {
            // Show modal and loading state
            const modal = new bootstrap.Modal(document.getElementById('historyMatchModal'));
            document.getElementById('historyMatchLoading').style.display = 'block';
            document.getElementById('historyMatchScoreboard').style.display = 'none';
            modal.show();

            // Fetch match data
            fetch(`/umbraco/surface/TrainingMatch/GetMatch?matchCode=${matchCode}`)
                .then(response => response.json())
                .then(result => {
                    document.getElementById('historyMatchLoading').style.display = 'none';

                    if (result.success) {
                        renderHistoryMatchModal(result.match);
                        document.getElementById('historyMatchScoreboard').style.display = 'block';
                    } else {
                        alert(result.message || 'Kunde inte ladda matchen');
                        bootstrap.Modal.getInstance(document.getElementById('historyMatchModal')).hide();
                    }
                })
                .catch(error => {
                    console.error('Error loading match:', error);
                    document.getElementById('historyMatchLoading').style.display = 'none';
                    alert('N친got gick fel vid laddning av matchen');
                    bootstrap.Modal.getInstance(document.getElementById('historyMatchModal')).hide();
                });
        }

        // Render history match modal content (read-only scoreboard)
        function renderHistoryMatchModal(match) {
            // Update header info
            document.getElementById('historyMatchName').textContent = match.matchName || 'Tr칛ningsmatch';
            document.getElementById('historyMatchCode').textContent = match.matchCode;
            document.getElementById('historyMatchWeaponClass').textContent = 'Klass ' + match.weaponClass;

            // Show/hide handicap badge
            const historyHandicapBadge = document.getElementById('historyHandicapBadge');
            if (historyHandicapBadge) {
                historyHandicapBadge.style.display = match.hasHandicap ? 'inline-block' : 'none';
            }

            // Format completed date
            const completedDate = match.completedDate ? new Date(match.completedDate) : new Date(match.createdDate);
            document.getElementById('historyMatchDate').textContent = completedDate.toLocaleDateString('sv-SE', {
                year: 'numeric', month: 'short', day: 'numeric'
            });

            // Build participant header row
            const headerRow = document.getElementById('historyParticipantHeaderRow');
            headerRow.innerHTML = '';

            // Find minimum series count for equalized scoring (like mobile app)
            const participantsWithScores = match.participants.filter(p => p.scores && p.scores.length > 0);
            const minSeriesCount = participantsWithScores.length > 0
                ? Math.min(...participantsWithScores.map(p => p.scores.length))
                : 0;

            // Helper to get equalized scores (first N series, sorted by seriesNumber)
            function getEqualizedScores(participant) {
                if (!participant.scores || participant.scores.length === 0) return [];
                return [...participant.scores]
                    .sort((a, b) => a.seriesNumber - b.seriesNumber)
                    .slice(0, minSeriesCount);
            }

            // Helper to calculate final score using equalized series (with handicap if applicable)
            function calculateFinalScore(participant) {
                const equalizedScores = getEqualizedScores(participant);
                const totalScore = equalizedScores.reduce((sum, s) => sum + s.total, 0);
                const seriesCount = equalizedScores.length;

                if (match.hasHandicap && participant.handicapPerSeries !== null && participant.handicapPerSeries !== undefined) {
                    const hcpPerSeries = roundToQuarter(participant.handicapPerSeries);
                    const handicapTotal = hcpPerSeries * seriesCount;
                    const maxPossible = 50 * seriesCount;
                    return Math.min(Math.round(totalScore + handicapTotal), maxPossible);
                }
                return totalScore;
            }

            // Sort participants by final score (with handicap if applicable)
            const sortedParticipants = [...match.participants].sort((a, b) => {
                return calculateFinalScore(b) - calculateFinalScore(a);
            });

            // Create ranking map
            const rankings = new Map();
            sortedParticipants.forEach((p, index) => {
                rankings.set(p.memberId, index + 1);
            });

            match.participants.forEach((participant) => {
                const th = document.createElement('th');
                th.className = 'participant-column';

                const ranking = rankings.get(participant.memberId);
                let rankBadge = '';
                if (ranking === 1) rankBadge = '<span class="badge bg-warning text-dark">游볞 1:a</span>';
                else if (ranking === 2) rankBadge = '<span class="badge bg-secondary">游볟 2:a</span>';
                else if (ranking === 3) rankBadge = '<span class="badge bg-danger">游볠 3:e</span>';
                else rankBadge = `<span class="badge bg-light text-dark">${ranking}:e</span>`;

                // Build handicap info if match has handicap enabled
                let handicapInfo = '';
                if (match.hasHandicap && participant.handicapPerSeries !== null && participant.handicapPerSeries !== undefined) {
                    const hcpDisplay = formatHandicap(participant.handicapPerSeries);
                    const provisionalBadge = participant.isProvisional
                        ? '<span class="provisional-badge" title="Provisoriskt handicap (f칛rre 칛n 8 matcher)">(P)</span>'
                        : '';
                    handicapInfo = `
                        <div class="participant-handicap">
                            <span class="handicap-value">${hcpDisplay}</span>
                            ${provisionalBadge}
                        </div>
                    `;
                }

                th.innerHTML = `
                    <div class="participant-header">
                        ${renderAvatarForHistory(participant)}
                        <div class="participant-name">${participant.firstName || 'Skytt'}</div>
                        ${handicapInfo}
                        ${rankBadge}
                    </div>
                `;
                headerRow.appendChild(th);
            });

            // Find max series count
            let maxSeries = 0;
            match.participants.forEach(p => {
                if (p.scores && p.scores.length > maxSeries) {
                    maxSeries = p.scores.length;
                }
            });

            // Build score rows
            const tbody = document.getElementById('historyScoreboardBody');
            tbody.innerHTML = '';

            // Summary row insertion points (after these series numbers)
            const summaryAfter = [6, 7, 10, 12];

            for (let seriesNum = 1; seriesNum <= maxSeries; seriesNum++) {
                const tr = document.createElement('tr');

                match.participants.forEach((participant) => {
                    const td = document.createElement('td');
                    td.className = 'score-cell';

                    const score = participant.scores?.find(s => s.seriesNumber === seriesNum);
                    if (score) {
                        // Build photo indicator
                        const hasPhoto = score.targetPhotoUrl && score.targetPhotoUrl.length > 0;
                        const photoIndicator = hasPhoto
                            ? '<i class="bi bi-camera-fill photo-indicator" style="position:absolute;left:4px;top:4px;font-size:0.7rem;color:#60a5fa;"></i>'
                            : '';

                        // Build reaction display
                        let reactionHtml = '';
                        if (score.reactions && score.reactions.length > 0) {
                            const firstEmoji = score.reactions[0].emoji;
                            const count = score.reactions.length;
                            reactionHtml = count > 1
                                ? `<span class="reaction-indicator">${firstEmoji}<small>+${count-1}</small></span>`
                                : `<span class="reaction-indicator">${firstEmoji}</span>`;
                        }

                        td.innerHTML = `
                            ${photoIndicator}
                            <span class="score-value">${score.total}</span>
                            ${score.xCount > 0 ? `<span class="x-count">${score.xCount}x</span>` : ''}
                            ${reactionHtml}
                        `;
                        td.classList.add('has-score');
                        td.style.position = 'relative';
                        td.style.cursor = 'pointer';

                        // Click to open photo viewer
                        td.onclick = () => openHistoryPhotoViewer(participant, score, match);
                    } else {
                        td.innerHTML = '<span class="score-empty">-</span>';
                    }

                    tr.appendChild(td);
                });

                tbody.appendChild(tr);

                // Add summary row after series 6, 7, 10, 12
                if (summaryAfter.includes(seriesNum) && seriesNum <= maxSeries) {
                    const summaryRow = document.createElement('tr');
                    summaryRow.className = 'summary-row';

                    match.participants.forEach((participant) => {
                        const td = document.createElement('td');
                        td.className = 'summary-cell';

                        // Calculate sum up to this series (using equalized approach - only count actual scores)
                        const scoresUpToSeries = (participant.scores || [])
                            .filter(s => s.seriesNumber <= seriesNum)
                            .sort((a, b) => a.seriesNumber - b.seriesNumber);
                        const sumTotal = scoresUpToSeries.reduce((sum, s) => sum + s.total, 0);
                        const sumX = scoresUpToSeries.reduce((sum, s) => sum + (s.xCount || 0), 0);

                        td.innerHTML = `
                            <span class="summary-total">${sumTotal}</span>
                            ${sumX > 0 ? `<span class="summary-x">(${sumX}x)</span>` : ''}
                        `;
                        summaryRow.appendChild(td);
                    });

                    tbody.appendChild(summaryRow);
                }
            }

            // Add total row (using equalized scores for fair comparison)
            const totalRow = document.createElement('tr');
            totalRow.className = 'total-row';

            match.participants.forEach(participant => {
                const td = document.createElement('td');
                td.className = 'total-cell';

                // Use equalized scores (first N series where N = min series count)
                const equalizedScores = getEqualizedScores(participant);
                const totalScore = equalizedScores.reduce((sum, s) => sum + s.total, 0);
                const totalX = equalizedScores.reduce((sum, s) => sum + (s.xCount || 0), 0);
                const effectiveSeriesCount = equalizedScores.length;
                const actualSeriesCount = participant.scores?.length || 0;

                // Show equalized series count, and actual if different
                const seriesDisplay = effectiveSeriesCount !== actualSeriesCount
                    ? `${effectiveSeriesCount} av ${actualSeriesCount} serier`
                    : `${effectiveSeriesCount} serier`;

                // Check if handicap is enabled and participant has handicap data
                if (match.hasHandicap && participant.handicapPerSeries !== null && participant.handicapPerSeries !== undefined) {
                    // Use quarter-point handicap, then round final score to integer
                    const hcpPerSeries = roundToQuarter(participant.handicapPerSeries);
                    const handicapTotal = hcpPerSeries * effectiveSeriesCount;
                    const maxPossible = 50 * effectiveSeriesCount;
                    let finalScore = totalScore + handicapTotal;
                    finalScore = Math.min(Math.round(finalScore), maxPossible);
                    const hcpTotalDisplay = formatHandicap(handicapTotal);

                    td.innerHTML = `
                        <div class="total-score handicap-final">${finalScore}</div>
                        <div class="total-handicap-breakdown">
                            <span class="raw-score">${totalScore}</span>
                            <span class="hcp-addition">${hcpTotalDisplay}</span>
                        </div>
                        <div class="total-details">${seriesDisplay}${totalX > 0 ? ` | ${totalX}x` : ''}</div>
                    `;
                } else {
                    td.innerHTML = `
                        <div class="total-score">${totalScore}</div>
                        <div class="total-details">${seriesDisplay}${totalX > 0 ? ` | ${totalX}x` : ''}</div>
                    `;
                }
                totalRow.appendChild(td);
            });

            tbody.appendChild(totalRow);
        }

        // Helper for rendering avatars in history modal
        function renderAvatarForHistory(participant) {
            if (participant.profilePictureUrl) {
                return `<img src="${participant.profilePictureUrl}" alt="${participant.firstName}"
                             class="participant-avatar">`;
            }

            const initials = ((participant.firstName?.[0] || '') + (participant.lastName?.[0] || '')).toUpperCase();
            return `<div class="participant-avatar participant-avatar-initials">${initials}</div>`;
        }

        // Open photo viewer for history modal (read-only, shows photo/score and reactions)
        function openHistoryPhotoViewer(participant, score, match) {
            const shooterName = participant.firstName || 'Skytt';
            const hasPhoto = score.targetPhotoUrl && score.targetPhotoUrl.length > 0;

            // Build shots display if available
            let shotsHtml = '';
            if (score.shots && score.shots.length > 0) {
                shotsHtml = `<div class="history-shots mt-2">
                    <small class="text-muted">Skott:</small>
                    <span class="ms-2">${score.shots.join(' - ')}</span>
                </div>`;
            }

            // Build reactions list
            let reactionsHtml = '';
            if (score.reactions && score.reactions.length > 0) {
                // Group reactions by emoji
                const grouped = {};
                score.reactions.forEach(r => {
                    if (!grouped[r.emoji]) grouped[r.emoji] = [];
                    grouped[r.emoji].push(r.firstName || 'Ok칛nd');
                });

                reactionsHtml = `<div class="history-reactions mt-3">
                    <small class="text-muted d-block mb-2">Reaktioner:</small>
                    ${Object.entries(grouped).map(([emoji, names]) => `
                        <div class="d-flex align-items-center gap-2 py-1">
                            <span class="fs-5">${emoji}</span>
                            <span class="text-muted small flex-grow-1">${names.join(', ')}</span>
                            <span class="badge bg-secondary">${names.length}</span>
                        </div>
                    `).join('')}
                </div>`;
            }

            // Build modal content
            const modalContent = `
                <div class="modal fade" id="historyPhotoModal" tabindex="-1">
                    <div class="modal-dialog modal-dialog-centered ${hasPhoto ? 'modal-lg' : ''}">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">
                                    ${shooterName} - Serie ${score.seriesNumber}
                                </h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                ${hasPhoto ? `
                                    <div class="text-center mb-3">
                                        <img src="${score.targetPhotoUrl}" class="img-fluid rounded"
                                             style="max-height: 400px;" alt="Tavla">
                                    </div>
                                ` : ''}
                                <div class="text-center">
                                    <div class="fs-2 fw-bold">${score.total}</div>
                                    ${score.xCount > 0 ? `<div class="text-muted">${score.xCount}x</div>` : ''}
                                    ${shotsHtml}
                                </div>
                                ${reactionsHtml}
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Remove existing modal if any
            const existingModal = document.getElementById('historyPhotoModal');
            if (existingModal) existingModal.remove();

            // Add modal to DOM and show
            document.body.insertAdjacentHTML('beforeend', modalContent);
            const modal = new bootstrap.Modal(document.getElementById('historyPhotoModal'));
            modal.show();

            // Clean up modal on hide
            document.getElementById('historyPhotoModal').addEventListener('hidden.bs.modal', function() {
                this.remove();
            });
        }

        // ===== SignalR Integration =====

        function initializeSignalR() {
            hubConnection = new signalR.HubConnectionBuilder()
                .withUrl("/hubs/trainingmatch")
                .withAutomaticReconnect([0, 2000, 5000, 10000, 30000])
                .build();

            // Event handlers
            hubConnection.on("JoinRequestReceived", (request) => {
                showJoinRequestNotification(request);
            });

            hubConnection.on("JoinRequestAccepted", async (matchCode) => {
                showToast('Din f칬rfr친gan har accepterats!', 'success');
                // Unregister as spectator first (wait for it to complete)
                await unregisterAsSpectator(matchCode);
                // Load the match
                loadMatch(matchCode);
                // Switch to current tab
                const currentTab = document.getElementById('current-tab');
                const bsTab = new bootstrap.Tab(currentTab);
                bsTab.show();
            });

            hubConnection.on("JoinRequestBlocked", (matchCode) => {
                showToast('Din f칬rfr친gan har avvisats.', 'danger');
            });

            hubConnection.on("ParticipantJoined", (participant) => {
                if (currentMatchCode) {
                    refreshMatch();
                }
            });

            hubConnection.on("ParticipantLeft", (memberId) => {
                if (currentMatchCode) {
                    refreshMatch();
                }
            });

            hubConnection.on("ScoreUpdated", (data) => {
                if (currentMatchCode) {
                    refreshMatch();
                }
            });

            hubConnection.on("MatchCompleted", (matchCode) => {
                if (currentMatchCode === matchCode) {
                    showToast('Matchen har avslutats', 'info');
                    refreshMatch();
                }
            });

            hubConnection.on("MatchDeleted", (matchCode) => {
                if (currentMatchCode === matchCode) {
                    showToast('Matchen har raderats', 'warning');
                    // Redirect back to match list after short delay
                    setTimeout(() => {
                        window.location.href = '/traningsmatchen';
                    }, 2000);
                }
            });

            hubConnection.on("MatchStarted", (matchCode) => {
                if (currentMatchCode === matchCode) {
                    // Update global state
                    if (window.currentMatchState) {
                        window.currentMatchState.hasStarted = true;
                    }
                    // Hide scheduled match banners
                    const bannerCreator = document.getElementById('scheduledMatchBannerCreator');
                    const bannerParticipant = document.getElementById('scheduledMatchBannerParticipant');
                    if (bannerCreator) bannerCreator.style.display = 'none';
                    if (bannerParticipant) bannerParticipant.style.display = 'none';
                    // Show toast notification
                    showToast('Matchen har startat! Du kan nu registrera resultat.', 'success');
                }
            });

            hubConnection.on("MatchRefresh", (matchCode) => {
                if (currentMatchCode === matchCode) {
                    refreshMatch();
                }
            });

            hubConnection.on("SpectatorListUpdated", (spectators) => {
                if (typeof updateSpectatorsDisplay === 'function') {
                    // Pass match status to hide spectators for completed matches
                    updateSpectatorsDisplay(spectators, currentMatch?.status);
                }
            });

            hubConnection.on("ReactionUpdated", (data) => {
                console.log("ReactionUpdated:", data);
                if (typeof updateReactionDisplay === 'function') {
                    updateReactionDisplay(data.targetMemberId, data.seriesNumber, data.reactions);
                }
            });

            hubConnection.on("SettingsUpdated", (data) => {
                console.log("SettingsUpdated:", data);
                // Reload match data to get updated settings and recalculated totals
                if (currentMatch && typeof loadMatchData === 'function') {
                    loadMatchData(currentMatch.matchCode, isSpectator);
                }
            });

            // Start connection
            hubConnection.start()
                .then(() => {
                    console.log("SignalR connected");
                })
                .catch(err => {
                    console.error("SignalR connection error:", err);
                });
        }

        // Join match SignalR group when viewing a match
        function joinMatchSignalRGroup(matchCode) {
            if (hubConnection && hubConnection.state === signalR.HubConnectionState.Connected) {
                hubConnection.invoke("JoinMatchGroup", matchCode);
                console.log("Joined match group for", matchCode);
            } else {
                // Retry when connected
                console.log("SignalR not connected, will retry joining match group...");
                setTimeout(() => joinMatchSignalRGroup(matchCode), 1000);
            }
        }

        // Join organizer group when creating/owning a match
        function joinOrganizerSignalRGroup(matchCode) {
            if (hubConnection && hubConnection.state === signalR.HubConnectionState.Connected) {
                hubConnection.invoke("JoinOrganizerGroup", matchCode);
                console.log("Joined organizer group for", matchCode);
            } else {
                // Retry when connected
                console.log("SignalR not connected, will retry joining organizer group...");
                setTimeout(() => joinOrganizerSignalRGroup(matchCode), 1000);
            }
        }

        // Leave match SignalR group
        function leaveMatchSignalRGroup(matchCode) {
            if (hubConnection && hubConnection.state === signalR.HubConnectionState.Connected) {
                hubConnection.invoke("LeaveMatchGroup", matchCode);
            }
        }

        // ===== Ongoing Matches Tab =====

        let ongoingMatchesLoaded = false;

        function loadOngoingMatchesIfNeeded() {
            if (!ongoingMatchesLoaded) {
                loadOngoingMatches();
            }
        }

        function loadOngoingMatches() {
            const container = document.getElementById('ongoingMatchesList');
            const loading = document.getElementById('ongoingMatchesLoading');
            const empty = document.getElementById('ongoingMatchesEmpty');

            if (loading) loading.style.display = 'block';
            if (container) container.style.display = 'none';
            if (empty) empty.style.display = 'none';

            fetch('/umbraco/surface/TrainingMatch/GetOngoingMatches')
                .then(response => response.json())
                .then(result => {
                    if (loading) loading.style.display = 'none';

                    if (result.success) {
                        // Refresh member ID from server response to keep client in sync
                        if (result.currentMemberId !== null && result.currentMemberId !== undefined) {
                            if (currentMemberId !== result.currentMemberId) {
                                console.log(`Member ID refreshed: ${currentMemberId} -> ${result.currentMemberId}`);
                            }
                            currentMemberId = result.currentMemberId;
                            document.body.dataset.memberId = result.currentMemberId;
                        }

                        ongoingMatchesLoaded = true;
                        renderOngoingMatches(result.matches);

                        // Update badge
                        const badge = document.getElementById('ongoingMatchCount');
                        if (badge && result.matches.length > 0) {
                            badge.textContent = result.matches.length;
                            badge.style.display = 'inline-block';
                        } else if (badge) {
                            badge.style.display = 'none';
                        }
                    } else {
                        console.error('Error loading ongoing matches:', result.message);
                        if (empty) empty.style.display = 'block';
                    }
                })
                .catch(error => {
                    console.error('Error loading ongoing matches:', error);
                    if (loading) loading.style.display = 'none';
                    if (empty) empty.style.display = 'block';
                });
        }

        function renderOngoingMatches(matches) {
            const container = document.getElementById('ongoingMatchesList');
            const empty = document.getElementById('ongoingMatchesEmpty');

            if (!container) return;

            if (!matches || matches.length === 0) {
                container.style.display = 'none';
                if (empty) empty.style.display = 'block';
                return;
            }

            container.style.display = 'block';
            if (empty) empty.style.display = 'none';

            container.innerHTML = matches.map(m => {
                const avatars = m.participants.slice(0, 5).map((p, i) => {
                    if (p.profilePictureUrl) {
                        return `<img src="${p.profilePictureUrl}" alt="${p.firstName}"
                                    class="rounded-circle border border-2 border-white"
                                    style="width: 35px; height: 35px; margin-left: ${i > 0 ? '-10px' : '0'}; z-index: ${5-i}; object-fit: cover;"
                                    title="${p.firstName} ${p.lastName}">`;
                    } else {
                        const initials = (p.firstName?.[0] || '') + (p.lastName?.[0] || '');
                        return `<span class="rounded-circle bg-primary text-white d-inline-flex align-items-center justify-content-center border border-2 border-white"
                                    style="width: 35px; height: 35px; margin-left: ${i > 0 ? '-10px' : '0'}; z-index: ${5-i}; font-size: 0.8rem;"
                                    title="${p.firstName} ${p.lastName}">${initials}</span>`;
                    }
                }).join('');

                const moreCount = m.participantCount > 5 ? `<span class="badge bg-secondary ms-1">+${m.participantCount - 5}</span>` : '';

                const startTimeInfo = !m.hasStarted && m.startDate
                    ? `<span class="badge bg-warning text-dark"><i class="bi bi-clock me-1"></i>Startar ${new Date(m.startDate).toLocaleString('sv-SE', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}</span>`
                    : `<small class="text-muted">${new Date(m.createdDate).toLocaleString('sv-SE', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}</small>`;

                const isMyMatch = m.createdByMemberId === currentMemberId;
                const canManage = isMyMatch || isCurrentUserAdmin;
                const isOpen = m.isOpen !== false; // Default to true if not set

                // Join button or lock icon based on isOpen
                let joinOrLock = '';
                if (!isMyMatch) {
                    if (isOpen) {
                        joinOrLock = `<button class="btn btn-sm btn-primary" onclick="event.stopPropagation(); joinMatchByCode('${m.matchCode}')">
                            <i class="bi bi-person-plus me-1"></i>G친 med
                        </button>`;
                    } else {
                        joinOrLock = `<span class="text-muted" title="Privat match - endast via l칛nk eller QR-kod">
                            <i class="bi bi-lock-fill"></i>
                        </span>`;
                    }
                }

                // Stop button for creator or admin
                const stopBtn = canManage
                    ? `<button class="btn btn-sm btn-outline-danger" onclick="stopMatchFromList('${m.matchCode}', '${(m.matchName || m.matchCode).replace(/'/g, "\\'")}')" title="Avsluta match">
                           <i class="bi bi-stop-circle"></i>
                       </button>`
                    : '';

                return `
                    <div class="col-12">
                        <div class="card h-100 shadow-sm hover-card">
                            <div class="card-body">
                                <div class="d-flex justify-content-between align-items-start mb-2">
                                    <div>
                                        <h6 class="mb-1">${m.matchName || m.matchCode}</h6>
                                        <span class="badge bg-info text-dark me-2">
                                            <i class="bi bi-bullseye me-1"></i>Klass ${m.weaponClass}
                                        </span>
                                        ${startTimeInfo}
                                    </div>
                                    <div class="d-flex align-items-center gap-2">
                                        ${!isOpen ? '<span class="badge bg-secondary"><i class="bi bi-lock-fill"></i></span>' : ''}
                                        ${isMyMatch ? '<span class="badge bg-success">Din match</span>' : ''}
                                        ${stopBtn}
                                    </div>
                                </div>
                                <div class="d-flex align-items-center mb-3">
                                    ${avatars}${moreCount}
                                    <span class="text-muted ms-2">${m.participantCount} deltagare</span>
                                </div>
                                <div class="d-flex gap-2">
                                    <button class="btn btn-sm btn-outline-primary" onclick="viewMatchAsSpectator('${m.matchCode}')">
                                        <i class="bi bi-eye me-1"></i>Visa
                                    </button>
                                    ${joinOrLock}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ===== Upcoming Matches Tab =====

        let upcomingMatchesLoaded = false;

        function loadUpcomingMatchesIfNeeded() {
            if (!upcomingMatchesLoaded) {
                loadUpcomingMatches();
            }
        }

        function loadUpcomingMatches() {
            const container = document.getElementById('upcomingMatchesList');
            const loading = document.getElementById('upcomingMatchesLoading');
            const empty = document.getElementById('upcomingMatchesEmpty');

            if (loading) loading.style.display = 'block';
            if (container) container.style.display = 'none';
            if (empty) empty.style.display = 'none';

            fetch('/umbraco/surface/TrainingMatch/GetUpcomingMatches')
                .then(response => response.json())
                .then(result => {
                    if (loading) loading.style.display = 'none';

                    if (result.success) {
                        // Refresh member ID from server response to keep client in sync
                        if (result.currentMemberId !== null && result.currentMemberId !== undefined) {
                            if (currentMemberId !== result.currentMemberId) {
                                console.log(`Member ID refreshed: ${currentMemberId} -> ${result.currentMemberId}`);
                            }
                            currentMemberId = result.currentMemberId;
                            document.body.dataset.memberId = result.currentMemberId;
                        }

                        upcomingMatchesLoaded = true;
                        renderUpcomingMatches(result.matches);

                        // Update badge
                        const badge = document.getElementById('upcomingMatchCount');
                        if (badge && result.matches.length > 0) {
                            badge.textContent = result.matches.length;
                            badge.style.display = 'inline-block';
                        } else if (badge) {
                            badge.style.display = 'none';
                        }
                    } else {
                        console.error('Error loading upcoming matches:', result.message);
                        if (empty) empty.style.display = 'block';
                    }
                })
                .catch(error => {
                    console.error('Error loading upcoming matches:', error);
                    if (loading) loading.style.display = 'none';
                    if (empty) empty.style.display = 'block';
                });
        }

        function renderUpcomingMatches(matches) {
            const container = document.getElementById('upcomingMatchesList');
            const empty = document.getElementById('upcomingMatchesEmpty');

            if (!container) return;

            if (!matches || matches.length === 0) {
                container.style.display = 'none';
                if (empty) empty.style.display = 'block';
                return;
            }

            container.style.display = 'block';
            if (empty) empty.style.display = 'none';

            container.innerHTML = matches.map(m => {
                const avatars = m.participants.slice(0, 5).map((p, i) => {
                    if (p.profilePictureUrl) {
                        return `<img src="${p.profilePictureUrl}" alt="${p.firstName}"
                                    class="rounded-circle border border-2 border-white"
                                    style="width: 35px; height: 35px; margin-left: ${i > 0 ? '-10px' : '0'}; z-index: ${5-i}; object-fit: cover;"
                                    title="${p.firstName} ${p.lastName}">`;
                    } else {
                        const initials = (p.firstName?.[0] || '') + (p.lastName?.[0] || '');
                        return `<span class="rounded-circle bg-info text-white d-inline-flex align-items-center justify-content-center border border-2 border-white"
                                    style="width: 35px; height: 35px; margin-left: ${i > 0 ? '-10px' : '0'}; z-index: ${5-i}; font-size: 0.8rem;"
                                    title="${p.firstName} ${p.lastName}">${initials}</span>`;
                    }
                }).join('');

                const moreCount = m.participantCount > 5 ? `<span class="badge bg-secondary ms-1">+${m.participantCount - 5}</span>` : '';

                // Format start date nicely
                const startDateStr = m.startDate
                    ? new Date(m.startDate).toLocaleString('sv-SE', { weekday: 'short', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })
                    : '';

                const isMyMatch = m.createdByMemberId === currentMemberId;
                const canManage = isMyMatch || isCurrentUserAdmin;
                const isOpen = m.isOpen !== false; // Default to true if not set

                // Join button or lock icon based on isOpen
                let joinOrLock = '';
                if (!isMyMatch) {
                    if (isOpen) {
                        joinOrLock = `<button class="btn btn-sm btn-primary" onclick="event.stopPropagation(); joinMatchByCode('${m.matchCode}')">
                            <i class="bi bi-person-plus me-1"></i>G친 med
                        </button>`;
                    } else {
                        joinOrLock = `<span class="text-muted" title="Privat match - endast via l칛nk eller QR-kod">
                            <i class="bi bi-lock-fill"></i>
                        </span>`;
                    }
                }

                // Delete button for creator or admin
                const deleteBtn = canManage
                    ? `<button class="btn btn-sm btn-outline-danger" onclick="deleteMatchFromList('${m.matchCode}', '${(m.matchName || m.matchCode).replace(/'/g, "\\'")}')" title="Radera match">
                           <i class="bi bi-trash"></i>
                       </button>`
                    : '';

                return `
                    <div class="col-12">
                        <div class="card h-100 shadow-sm upcoming-match-card">
                            <div class="card-body">
                                <div class="d-flex justify-content-between align-items-start mb-2">
                                    <div>
                                        <h6 class="mb-1">${m.matchName || m.matchCode}</h6>
                                        <span class="badge bg-info text-dark me-2">
                                            <i class="bi bi-bullseye me-1"></i>Klass ${m.weaponClass}
                                        </span>
                                        <span class="scheduled-time">
                                            <i class="bi bi-calendar-event me-1"></i>${startDateStr}
                                        </span>
                                    </div>
                                    <div class="d-flex align-items-center gap-2">
                                        ${!isOpen ? '<span class="badge bg-secondary"><i class="bi bi-lock-fill"></i></span>' : ''}
                                        ${isMyMatch ? '<span class="badge bg-success">Din match</span>' : ''}
                                        ${deleteBtn}
                                    </div>
                                </div>
                                <div class="d-flex align-items-center mb-3">
                                    ${avatars}${moreCount}
                                    <span class="text-muted ms-2">${m.participantCount} deltagare</span>
                                </div>
                                <div class="d-flex gap-2">
                                    <button class="btn btn-sm btn-outline-primary" onclick="viewMatchAsSpectator('${m.matchCode}')">
                                        <i class="bi bi-eye me-1"></i>Visa
                                    </button>
                                    ${joinOrLock}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ===== Auto-close Stale Matches =====

        function autoCloseStaleMatches() {
            return fetch('/umbraco/surface/TrainingMatch/AutoCloseStaleMatches')
                .then(response => response.json())
                .then(result => {
                    if (result.success && result.closedCount > 0) {
                        console.log(`Auto-closed ${result.closedCount} stale matches`);
                    }
                    return result;
                })
                .catch(error => {
                    console.error('Error auto-closing stale matches:', error);
                    return { success: false };
                });
        }

        // ===== Badge Count Updates =====

        function loadBadgeCounts() {
            // Single lightweight call to get both counts
            fetch('/umbraco/surface/TrainingMatch/GetMatchCounts')
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        // Update ongoing badge
                        const ongoingBadge = document.getElementById('ongoingMatchCount');
                        if (ongoingBadge) {
                            if (result.ongoingCount > 0) {
                                ongoingBadge.textContent = result.ongoingCount;
                                ongoingBadge.style.display = 'inline-block';
                            } else {
                                ongoingBadge.style.display = 'none';
                            }
                        }

                        // Update upcoming badge
                        const upcomingBadge = document.getElementById('upcomingMatchCount');
                        if (upcomingBadge) {
                            if (result.upcomingCount > 0) {
                                upcomingBadge.textContent = result.upcomingCount;
                                upcomingBadge.style.display = 'inline-block';
                            } else {
                                upcomingBadge.style.display = 'none';
                            }
                        }
                    }
                })
                .catch(error => console.error('Error loading match counts:', error));
        }

        // Request to join the current match (from spectator mode)
        function requestJoinCurrentMatch() {
            if (!currentMatchCode) return;
            requestJoinMatch(currentMatchCode);
        }

        // View match as spectator (or as participant if already joined)
        function viewMatchAsSpectator(matchCode) {
            showLoading();
            currentMatchCode = matchCode;

            fetch(`/umbraco/surface/TrainingMatch/ViewMatchAsSpectator?matchCode=${matchCode}`)
                .then(response => response.json())
                .then(result => {
                    hideLoading();

                    if (result.success) {
                        currentMatch = result.match;

                        // Check if user is actually a participant
                        const myMemberId = parseInt(document.body.dataset.memberId) || 0;
                        const isParticipant = result.match.participants.some(p => p.memberId === myMemberId);

                        // Only set as spectator if NOT a participant
                        isSpectator = !isParticipant && result.isSpectator;

                        // Switch to current tab
                        const currentTab = document.getElementById('current-tab');
                        const bsTab = new bootstrap.Tab(currentTab);
                        bsTab.show();

                        showActiveMatchState();
                        renderScoreboard(result.match);

                        // Join SignalR group for real-time updates
                        joinMatchSignalRGroup(matchCode);

                        // If participant and creator, also join organizer group
                        if (isParticipant && result.match.createdByMemberId === myMemberId) {
                            joinOrganizerSignalRGroup(matchCode);
                            loadPendingJoinRequests(matchCode);
                        }

                        // If spectator, register as spectator for live viewer count
                        if (isSpectator && myMemberId > 0) {
                            registerAsSpectator(matchCode);
                        }
                    } else {
                        alert(result.message || 'Kunde inte ladda matchen');
                    }
                })
                .catch(error => {
                    console.error('Error viewing match:', error);
                    hideLoading();
                    alert('N친got gick fel');
                });
        }

        // Register current user as a spectator
        function registerAsSpectator(matchCode) {
            if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
                console.log("SignalR not connected, will retry registering as spectator...");
                setTimeout(() => registerAsSpectator(matchCode), 1000);
                return;
            }

            const memberId = parseInt(document.body.dataset.memberId) || 0;
            const memberName = document.body.dataset.memberName || 'Ok칛nd';
            const profilePictureUrl = document.body.dataset.profilePictureUrl || '';
            const clubName = document.body.dataset.clubName || '';

            hubConnection.invoke("RegisterSpectator", matchCode, memberId, memberName, profilePictureUrl, clubName)
                .then(() => console.log("Registered as spectator"))
                .catch(err => console.error("Error registering as spectator:", err));
        }

        // Unregister current user as a spectator (when joining as participant)
        // Returns a Promise that resolves when unregistration is complete
        function unregisterAsSpectator(matchCode) {
            return new Promise((resolve) => {
                if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
                    resolve();
                    return;
                }

                hubConnection.invoke("UnregisterSpectator", matchCode)
                    .then(() => {
                        console.log("Unregistered as spectator");
                        resolve();
                    })
                    .catch(err => {
                        console.error("Error unregistering as spectator:", err);
                        resolve(); // Resolve anyway to not block the flow
                    });
            });
        }

        // Request to join a match
        function requestJoinMatch(matchCode) {
            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;

            fetch('/umbraco/surface/TrainingMatch/RequestJoinMatch', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': token || ''
                },
                body: JSON.stringify({ matchCode: matchCode })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    showToast('Din f칬rfr친gan har skickats till matchv칛rden', 'success');
                } else {
                    showToast(result.message || 'Kunde inte skicka f칬rfr친gan', 'danger');
                }
            })
            .catch(error => {
                console.error('Error requesting to join:', error);
                showToast('N친got gick fel', 'danger');
            });
        }

        // ===== Join Request Handling (for organizer) =====

        let pendingJoinRequests = [];

        function showJoinRequestNotification(request) {
            // Show toast notification
            showToast(`${request.memberName} vill g친 med i din match`, 'info', 10000);

            // Show modal for response
            showJoinRequestModal(request);
        }

        function showJoinRequestModal(request) {
            const modal = document.getElementById('joinRequestModal');
            if (!modal) return;

            document.getElementById('joinRequestMemberName').textContent = request.memberName;

            const avatarContainer = document.getElementById('joinRequestAvatar');
            if (request.profilePictureUrl) {
                avatarContainer.innerHTML = `<img src="${request.profilePictureUrl}" alt="${request.memberName}"
                                                class="rounded-circle" style="width: 80px; height: 80px; object-fit: cover;">`;
            } else {
                const initials = request.memberName.split(' ').map(n => n[0]).join('').substring(0, 2);
                avatarContainer.innerHTML = `<span class="rounded-circle bg-primary text-white d-inline-flex align-items-center justify-content-center"
                                                style="width: 80px; height: 80px; font-size: 1.5rem;">${initials}</span>`;
            }

            // Store request ID for response
            modal.dataset.requestId = request.id;
            modal.dataset.matchCode = request.matchCode;

            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
        }

        function respondToJoinRequest(action) {
            const modal = document.getElementById('joinRequestModal');
            const requestId = modal.dataset.requestId;
            const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;

            fetch('/umbraco/surface/TrainingMatch/RespondToJoinRequest', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': token || ''
                },
                body: JSON.stringify({
                    requestId: parseInt(requestId),
                    action: action
                })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    showToast(result.message, 'success');
                    bootstrap.Modal.getInstance(modal).hide();

                    // Refresh match to show new participant
                    if (action === 'Accept' && currentMatchCode) {
                        refreshMatch();
                    }
                } else {
                    showToast(result.message || 'N친got gick fel', 'danger');
                }
            })
            .catch(error => {
                console.error('Error responding to join request:', error);
                showToast('N친got gick fel', 'danger');
            });
        }

        // Load pending join requests (called when organizer views their match)
        function loadPendingJoinRequests(matchCode) {
            fetch(`/umbraco/surface/TrainingMatch/GetPendingJoinRequests?matchCode=${matchCode}`)
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        pendingJoinRequests = result.requests;
                        updatePendingRequestsBadge();
                    }
                })
                .catch(error => {
                    console.error('Error loading pending requests:', error);
                });
        }

        function updatePendingRequestsBadge() {
            const badge = document.getElementById('pendingRequestsBadge');
            if (badge && pendingJoinRequests.length > 0) {
                badge.textContent = pendingJoinRequests.length;
                badge.style.display = 'inline-block';
            } else if (badge) {
                badge.style.display = 'none';
            }
        }

        // ===== Toast Notifications =====

        function showToast(message, type = 'info', duration = 5000) {
            const container = document.getElementById('toastContainer') || createToastContainer();

            const toast = document.createElement('div');
            toast.className = `toast align-items-center text-white bg-${type} border-0`;
            toast.setAttribute('role', 'alert');
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            `;

            container.appendChild(toast);

            const bsToast = new bootstrap.Toast(toast, { delay: duration });
            bsToast.show();

            toast.addEventListener('hidden.bs.toast', () => {
                toast.remove();
            });
        }

        function createToastContainer() {
            const container = document.createElement('div');
            container.id = 'toastContainer';
            container.className = 'toast-container position-fixed bottom-0 end-0 p-3';
            container.style.zIndex = '1100';
            document.body.appendChild(container);
            return container;
        }

        // ===== Emoji Reactions & Photo Viewer =====

        let emojiPickerTarget = null; // { memberId, seriesNumber, scoreData }
        let currentPhotoViewerData = null; // For photo modal reactions

        // Handle click on non-editable score cell (for reactions and photo viewing)
        function handleScoreCellClick(event, memberId, seriesNumber, scoreData) {
            event.stopPropagation();

            // Don't allow reacting to own scores
            if (memberId === currentMemberId) {
                // If it has a photo, still allow viewing it
                if (scoreData.targetPhotoUrl) {
                    openPhotoViewer(memberId, seriesNumber, scoreData);
                }
                return;
            }

            // If score has a photo, open photo viewer (which has reaction buttons)
            if (scoreData.targetPhotoUrl) {
                openPhotoViewer(memberId, seriesNumber, scoreData);
            } else {
                // No photo - open emoji picker directly
                openEmojiPicker(event, memberId, seriesNumber, scoreData);
            }
        }

        // Open emoji picker popup at click position
        function openEmojiPicker(event, memberId, seriesNumber, scoreData) {
            const picker = document.getElementById('emojiPicker');
            const rect = event.target.getBoundingClientRect();

            // Position picker near the click
            picker.style.display = 'block';
            picker.style.left = `${Math.min(rect.left, window.innerWidth - 250)}px`;
            picker.style.top = `${rect.bottom + 5}px`;

            emojiPickerTarget = { memberId, seriesNumber, scoreData };

            // Highlight current user's reaction if any
            highlightCurrentReaction(scoreData.reactions);
        }

        // Close emoji picker
        function closeEmojiPicker() {
            const picker = document.getElementById('emojiPicker');
            if (picker) {
                picker.style.display = 'none';
            }
            emojiPickerTarget = null;
        }

        // Highlight the user's current reaction in the picker
        function highlightCurrentReaction(reactions) {
            // Clear all highlights
            document.querySelectorAll('.emoji-btn').forEach(btn => {
                btn.classList.remove('selected');
            });

            if (!reactions) return;

            // Find current user's reaction
            const myReaction = reactions.find(r => r.memberId === currentMemberId);
            if (myReaction) {
                const btn = document.querySelector(`.emoji-btn[data-emoji="${myReaction.emoji}"]`);
                if (btn) {
                    btn.classList.add('selected');
                }
            }
        }

        // Send reaction to API
        async function addReaction(emoji, fromModal = false) {
            const target = fromModal ? currentPhotoViewerData : emojiPickerTarget;
            if (!target) return;

            try {
                const response = await fetch(`/api/match/${currentMatchCode}/series/${target.seriesNumber}/reaction`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        targetMemberId: target.memberId,
                        emoji: emoji
                    })
                });

                if (response.ok) {
                    if (!fromModal) {
                        closeEmojiPicker();
                    } else {
                        // Update modal button states
                        updateModalReactionButtons(emoji);
                    }
                    // SignalR will handle the UI update
                } else {
                    const result = await response.json();
                    showToast(result.message || 'Kunde inte spara reaktion', 'danger');
                }
            } catch (error) {
                console.error('Failed to add reaction:', error);
                showToast('N친got gick fel', 'danger');
            }
        }

        // Update modal reaction button states
        function updateModalReactionButtons(selectedEmoji) {
            document.querySelectorAll('.emoji-modal-btn').forEach(btn => {
                const isSelected = btn.dataset.emoji === selectedEmoji;
                btn.classList.toggle('active', isSelected);
            });
        }

        // Open photo viewer modal
        function openPhotoViewer(memberId, seriesNumber, scoreData) {
            currentPhotoViewerData = { memberId, seriesNumber, scoreData };

            // Update modal content
            document.getElementById('photoSeriesNumber').textContent = seriesNumber;
            document.getElementById('photoScoreTotal').textContent = scoreData.total;

            // X count
            const xCountContainer = document.getElementById('photoXCountContainer');
            const xCountEl = document.getElementById('photoXCount');
            if (scoreData.xCount > 0) {
                xCountEl.textContent = `${scoreData.xCount}x`;
                xCountContainer.style.display = 'block';
            } else {
                xCountContainer.style.display = 'none';
            }

            // Find shooter name from current match data
            const shooter = currentMatch?.participants?.find(p => p.memberId === memberId);
            document.getElementById('photoShooterName').textContent = shooter?.firstName || 'Ok칛nd';

            // Photo handling
            const loadingSpinner = document.getElementById('photoLoadingSpinner');
            const photoImage = document.getElementById('targetPhotoImage');
            const noPhotoMsg = document.getElementById('noPhotoMessage');

            if (scoreData.targetPhotoUrl) {
                loadingSpinner.style.display = 'block';
                photoImage.style.display = 'none';
                noPhotoMsg.style.display = 'none';

                photoImage.onload = () => {
                    loadingSpinner.style.display = 'none';
                    photoImage.style.display = 'block';
                };
                photoImage.onerror = () => {
                    loadingSpinner.style.display = 'none';
                    noPhotoMsg.style.display = 'block';
                };
                photoImage.src = scoreData.targetPhotoUrl;
            } else {
                loadingSpinner.style.display = 'none';
                photoImage.style.display = 'none';
                noPhotoMsg.style.display = 'block';
            }

            // Update modal reaction buttons - highlight user's current reaction
            document.querySelectorAll('.emoji-modal-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (scoreData.reactions) {
                const myReaction = scoreData.reactions.find(r => r.memberId === currentMemberId);
                if (myReaction) {
                    const btn = document.querySelector(`.emoji-modal-btn[data-emoji="${myReaction.emoji}"]`);
                    if (btn) btn.classList.add('active');
                }
            }

            // Show/hide reaction buttons based on whether it's own score
            const reactionRow = document.querySelector('.emoji-reaction-row');
            if (reactionRow) {
                reactionRow.style.display = memberId === currentMemberId ? 'none' : 'flex';
            }

            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('targetPhotoModal'));
            modal.show();
        }

        // Update reaction display when SignalR fires
        function updateReactionDisplay(memberId, seriesNumber, reactions) {
            // Find the score-clickable div with the matching data attributes
            const clickableDiv = document.querySelector(
                `.score-clickable[data-member-id="${memberId}"][data-series="${seriesNumber}"]`
            );

            if (clickableDiv) {
                // Find or create the reaction-display span (new responsive version)
                let reactionSpan = clickableDiv.querySelector('.reaction-display');

                if (reactions && reactions.length > 0) {
                    // Group reactions by emoji (same logic as buildInlineReactionHtml)
                    const grouped = {};
                    reactions.forEach(r => {
                        if (!grouped[r.emoji]) {
                            grouped[r.emoji] = { emoji: r.emoji, count: 0, names: [] };
                        }
                        grouped[r.emoji].count++;
                        grouped[r.emoji].names.push(r.firstName || 'Ok칛nd');
                    });

                    const groups = Object.values(grouped).sort((a, b) => b.count - a.count);
                    const totalCount = reactions.length;
                    const tooltip = reactions.map(r => `${r.firstName || 'Ok칛nd'}: ${r.emoji}`).join(', ');
                    const groupsJson = JSON.stringify(groups).replace(/'/g, '&#39;').replace(/"/g, '&quot;');

                    if (reactionSpan) {
                        // Update existing span's data attributes
                        reactionSpan.dataset.reactions = groupsJson;
                        reactionSpan.dataset.total = totalCount;
                        reactionSpan.title = tooltip;
                    } else {
                        // Create new reaction span after score-value
                        const scoreValue = clickableDiv.querySelector('.score-value');
                        if (scoreValue) {
                            reactionSpan = document.createElement('span');
                            reactionSpan.className = 'reaction-display';
                            reactionSpan.dataset.reactions = groupsJson;
                            reactionSpan.dataset.total = totalCount;
                            reactionSpan.title = tooltip;
                            reactionSpan.onclick = function(e) {
                                e.stopPropagation();
                                openReactorsPopup(this);
                            };
                            scoreValue.insertAdjacentElement('afterend', reactionSpan);
                        }
                    }

                    // Update the responsive display content
                    if (typeof updateReactionDisplays === 'function') {
                        setTimeout(updateReactionDisplays, 50);
                    }
                } else {
                    // Remove reaction if no reactions
                    if (reactionSpan) {
                        reactionSpan.remove();
                    }
                }
            }

            // Also update photo modal if open for this score
            if (currentPhotoViewerData &&
                currentPhotoViewerData.memberId === memberId &&
                currentPhotoViewerData.seriesNumber === seriesNumber) {
                // Update the scoreData reference
                currentPhotoViewerData.scoreData.reactions = reactions;
                // Update button states
                document.querySelectorAll('.emoji-modal-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                if (reactions) {
                    const myReaction = reactions.find(r => r.memberId === currentMemberId);
                    if (myReaction) {
                        const btn = document.querySelector(`.emoji-modal-btn[data-emoji="${myReaction.emoji}"]`);
                        if (btn) btn.classList.add('active');
                    }
                }
            }
        }

        // Event listeners for emoji picker
        document.addEventListener('DOMContentLoaded', function() {
            // Click outside to close picker
            document.addEventListener('click', (e) => {
                const picker = document.getElementById('emojiPicker');
                if (picker && picker.style.display !== 'none') {
                    if (!e.target.closest('.emoji-picker') && !e.target.closest('.score-clickable')) {
                        closeEmojiPicker();
                    }
                }
            });

            // Emoji picker buttons
            document.querySelectorAll('.emoji-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addReaction(btn.dataset.emoji, false);
                });
            });

            // Photo modal emoji buttons
            document.querySelectorAll('.emoji-modal-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addReaction(btn.dataset.emoji, true);
                });
            });
        });

        // ===== Android App Test Access =====

        async function requestAndroidTestAccess() {
            const btn = document.getElementById('requestTestAccessBtn');
            const originalText = btn.innerHTML;

            try {
                btn.disabled = true;
                btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Skickar...';

                const response = await fetch('/umbraco/surface/TrainingMatch/RequestAndroidTestAccess', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // Close modal and show success toast
                    const modal = bootstrap.Modal.getInstance(document.getElementById('androidAppModal'));
                    modal.hide();
                    showToast('Din f칬rfr친gan har skickats! Du kommer f친 ett e-postmeddelande n칛r du har lagts till som testare.', 'success', 8000);
                } else {
                    showToast(result.message || 'N친got gick fel. F칬rs칬k igen senare.', 'danger');
                }
            } catch (error) {
                console.error('Error requesting test access:', error);
                showToast('N친got gick fel. F칬rs칬k igen senare.', 'danger');
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }

        // Initialize SignalR on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeSignalR();
        });
    </script>
}

<!-- Share Match Modal -->
<div class="modal fade" id="shareMatchModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-share me-2"></i>Dela match</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center">
                <p class="mb-3">Skanna QR-koden eller dela l칛nken f칬r att g친 med i matchen</p>

                <!-- QR Code -->
                <div class="mb-4">
                    <img id="shareQrCode" src="" alt="QR Code" class="img-fluid" style="max-width: 200px;">
                </div>

                <!-- Match Code -->
                <div class="mb-3">
                    <span class="badge bg-primary fs-4 px-4 py-2" id="shareMatchCode">ABC123</span>
                </div>

                <!-- Share Link -->
                <div class="input-group mb-3">
                    <input type="text" class="form-control" id="shareMatchLink" readonly>
                    <button class="btn btn-outline-primary" type="button" onclick="copyShareLink()">
                        <i class="bi bi-clipboard"></i> Kopiera
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Join Request Modal (for organizer) -->
<div class="modal fade" id="joinRequestModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title">
                    <i class="bi bi-person-plus me-2"></i>F칬rfr친gan om att g친 med
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center py-4">
                <div id="joinRequestAvatar" class="mb-3">
                    <!-- Avatar populated dynamically -->
                </div>
                <h5 id="joinRequestMemberName">Ok칛nd</h5>
                <p class="text-muted">vill g친 med i din match</p>
            </div>
            <div class="modal-footer justify-content-center">
                <button class="btn btn-danger" onclick="respondToJoinRequest('Block')">
                    <i class="bi bi-x-circle me-1"></i> Blockera
                </button>
                <button class="btn btn-success" onclick="respondToJoinRequest('Accept')">
                    <i class="bi bi-check-circle me-1"></i> Acceptera
                </button>
            </div>
        </div>
    </div>
</div>

<!-- History Match Modal (Read-only view of completed matches) -->
<div class="modal fade" id="historyMatchModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header bg-secondary text-white">
                <div>
                    <h5 class="modal-title mb-0">
                        <i class="bi bi-clock-history me-2"></i><span id="historyMatchName">Match</span>
                        <span id="historyHandicapBadge" class="badge bg-warning text-dark ms-2" style="display: none;" title="Handicapsystem aktiverat">
                            <i class="bi bi-balance-scale me-1"></i>HCP
                        </span>
                    </h5>
                    <small>
                        <span id="historyMatchWeaponClass">Klass C</span> |
                        <span id="historyMatchDate">-</span> |
                        Kod: <span id="historyMatchCode">------</span>
                    </small>
                </div>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="St칛ng"></button>
            </div>
            <div class="modal-body p-0">
                <!-- Loading state -->
                <div id="historyMatchLoading" class="text-center py-5">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Laddar...</span>
                    </div>
                </div>
                <!-- Scoreboard container -->
                <div id="historyMatchScoreboard" style="display: none;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard-table" id="historyScoreboardTable">
                            <thead>
                                <tr id="historyParticipantHeaderRow"></tr>
                            </thead>
                            <tbody id="historyScoreboardBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                    <i class="bi bi-x-lg me-1"></i>St칛ng
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Shooter Class Selection Modal -->
<div class="modal fade" id="shooterClassModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-warning">
                <h5 class="modal-title">
                    <i class="bi bi-balance-scale me-2"></i>V칛lj din skytteklass
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-3">
                    Denna match anv칛nder handicapsystemet. F칬r att kunna g친 med beh칬ver du ange din skytteklass.
                    Detta sparas i din profil f칬r framtida matcher.
                </p>
                <div class="alert alert-info small">
                    <i class="bi bi-info-circle me-1"></i>
                    Din skytteklass best칛mmer ditt provisoriska handicap tills du har spelat 5 matcher.
                </div>
                <div class="d-flex flex-column gap-2 mt-3">
                    <div class="form-check shooter-class-option">
                        <input class="form-check-input" type="radio" name="shooterClassRadio"
                               id="shooterClass1" value="Klass 1 - Nyb칬rjare">
                        <label class="form-check-label w-100" for="shooterClass1">
                            <strong>Klass 1 - Nyb칬rjare</strong>
                        </label>
                    </div>
                    <div class="form-check shooter-class-option">
                        <input class="form-check-input" type="radio" name="shooterClassRadio"
                               id="shooterClass2" value="Klass 2 - Guldm칛rkesskytt">
                        <label class="form-check-label w-100" for="shooterClass2">
                            <strong>Klass 2 - Guldm칛rkesskytt</strong>
                        </label>
                    </div>
                    <div class="form-check shooter-class-option">
                        <input class="form-check-input" type="radio" name="shooterClassRadio"
                               id="shooterClass3" value="Klass 3 - Riksm칛stare">
                        <label class="form-check-label w-100" for="shooterClass3">
                            <strong>Klass 3 - Riksm칛stare</strong>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Avbryt</button>
                <button type="button" class="btn btn-success" id="saveShooterClassBtn" onclick="saveShooterClassAndJoin()">
                    <i class="bi bi-check-circle me-1"></i>Spara och g친 med
                </button>
            </div>
        </div>
    </div>
</div>

<style>
    /* Shooter class selection styling */
    .shooter-class-option {
        border: 1px solid var(--bs-border-color);
        border-radius: 8px;
        padding: 12px 12px 12px 40px;
        transition: all 0.15s ease;
        cursor: pointer;
    }

        .shooter-class-option:hover {
            background-color: var(--bs-tertiary-bg);
            border-color: var(--bs-primary);
        }

        .shooter-class-option:has(input:checked) {
            background-color: rgba(25, 135, 84, 0.1);
            border-color: var(--bs-success);
        }

    /* History modal summary rows */
    #historyScoreboardBody .summary-row {
        background-color: var(--bs-tertiary-bg);
        border-top: 2px solid var(--bs-border-color);
        border-bottom: 2px solid var(--bs-border-color);
    }

    #historyScoreboardBody .summary-cell {
        text-align: center;
        padding: 6px 8px !important;
        font-weight: 600;
    }

    #historyScoreboardBody .summary-total {
        font-size: 1rem;
        color: var(--bs-primary);
    }

    #historyScoreboardBody .summary-x {
        font-size: 0.75rem;
        color: var(--bs-secondary-color);
        margin-left: 4px;
    }

    /* History modal reaction indicator */
    #historyScoreboardBody .reaction-indicator {
        display: inline-block;
        font-size: 0.8rem;
        margin-left: 4px;
        vertical-align: middle;
    }

    #historyScoreboardBody .reaction-indicator small {
        font-size: 0.65rem;
        color: var(--bs-secondary-color);
    }

    /* History modal score cells */
    #historyScoreboardBody .score-cell.has-score:hover {
        background-color: var(--bs-tertiary-bg);
    }
</style>

@Html.AntiForgeryToken()
